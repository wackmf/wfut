diff --git a/WFCode/Classes/WFASRocketLauncher.uc b/WFCode/Classes/WFASRocketLauncher.uc
index d8a8605..029d10a 100644
--- a/WFCode/Classes/WFASRocketLauncher.uc
+++ b/WFCode/Classes/WFASRocketLauncher.uc
@@ -79,7 +79,7 @@ defaultproperties
      BobDamping=0.975000
      PickupViewMesh=LodMesh'Botpack.WHPick'
      ThirdPersonMesh=LodMesh'Botpack.WHHand'
-     StatusIcon=Texture'Botpack.Icons.UseWarH'
+     StatusIcon=Texture'WFMedia.WeaponSentryKiller'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.UseWarH'
      Mesh=LodMesh'Botpack.WHPick'
diff --git a/WFCode/Classes/WFAlarmArea.uc b/WFCode/Classes/WFAlarmArea.uc
index f04d9de..fbbb164 100644
--- a/WFCode/Classes/WFAlarmArea.uc
+++ b/WFCode/Classes/WFAlarmArea.uc
@@ -43,6 +43,9 @@ function bool CheckAlarmRadius()
 	local int i;
 	local pawn p;
 
+	if ((Owner != None) && (Location != Owner.Location))
+		SetLocation(Owner.Location);
+
 	for (i=0; i<4; i++)
 	{
 		if (Touching[i] != None)
diff --git a/WFCode/Classes/WFArmor.uc b/WFCode/Classes/WFArmor.uc
index 892fb17..edbd374 100644
--- a/WFCode/Classes/WFArmor.uc
+++ b/WFCode/Classes/WFArmor.uc
@@ -100,6 +100,13 @@ function int ArmorAbsorbDamage(int Damage, name DamageType, vector HitLocation)
 	return (Damage - ArmorDamage);
 }
 
+// negative values will reduce armor
+function AddArmor(int Amount)
+{
+	super.AddArmor(Amount);
+	UpdateCharge();
+}
+
 function UpdateCharge()
 {
 	local WFBot aBot;
diff --git a/WFCode/Classes/WFAutoCannon.uc b/WFCode/Classes/WFAutoCannon.uc
index 77e6f8d..1c88043 100644
--- a/WFCode/Classes/WFAutoCannon.uc
+++ b/WFCode/Classes/WFAutoCannon.uc
@@ -32,8 +32,8 @@ function bool IsValidTarget(actor Other)
 				return false;
 
         if ( ((P.PlayerReplicationInfo != none) && (SameTeamAs(P.PlayerReplicationInfo.Team))
-        	|| class'WFDisguise'.static.IsDisguised(P.PlayerReplicationInfo))
-        	|| TargetIsCloaked(P))
+        	|| ( !class'WFCloaker'.static.IsHalfCloaked(P) && (class'WFDisguise'.static.IsDisguised(P.PlayerReplicationInfo))
+        		|| TargetIsCloaked(P)) ) )
 				return false;
 
 		if (Other.IsA('WFS_PCSystemAutoCannon') && SameTeamAs(WFS_PCSystemAutoCannon(Other).MyTeam))
@@ -123,4 +123,5 @@ defaultproperties
      HUDMenuClass=Class'WFCode.WFCannonHUDMenu'
      bUseTeamSkins=True
      FovAngle=220.000000
+     bAlwaysRelevant=True
 }
diff --git a/WFCode/Classes/WFAutoDoc.uc b/WFCode/Classes/WFAutoDoc.uc
index aac8da3..9be00c8 100644
--- a/WFCode/Classes/WFAutoDoc.uc
+++ b/WFCode/Classes/WFAutoDoc.uc
@@ -1,7 +1,7 @@
 //=============================================================================
 // WFAutoDoc.
 //=============================================================================
-class WFAutoDoc extends TournamentPickup;
+class WFAutoDoc extends WFPickup;
 
 var() int HealingDelay;
 var() int HealingAmount;
diff --git a/WFCode/Classes/WFBackpack.uc b/WFCode/Classes/WFBackpack.uc
index 736e675..964310c 100644
--- a/WFCode/Classes/WFBackpack.uc
+++ b/WFCode/Classes/WFBackpack.uc
@@ -181,7 +181,7 @@ function PickupFunction(pawn Other)
 			{
 				ArmorInv = WFS_PCSArmor(Item);
 				if (ArmorInv != None)
-					ArmorInv.Charge = Min(ArmorInv.Charge + ArmorAmount, ArmorInv.MaxCharge);
+					ArmorInv.AddArmor(ArmorAmount);
 			}
 
 			// add grenades
diff --git a/WFCode/Classes/WFBioRifle.uc b/WFCode/Classes/WFBioRifle.uc
index e255a67..d1e9fea 100644
--- a/WFCode/Classes/WFBioRifle.uc
+++ b/WFCode/Classes/WFBioRifle.uc
@@ -109,6 +109,7 @@ function AltFire( float Value )
 
 	if ((GetStateName() == 'AltFiring') || AmmoType.UseAmmo(1))
 	{
+		NotifyFired();
 		GotoState ('AltFiring');
 		bPointing=True;
 		bCanClientFire = true;
@@ -257,7 +258,7 @@ defaultproperties
      BobDamping=0.972000
      PickupViewMesh=LodMesh'Botpack.BRifle2Pick'
      ThirdPersonMesh=LodMesh'Botpack.BRifle23'
-     StatusIcon=Texture'Botpack.Icons.UseBio'
+     StatusIcon=Texture'WFMedia.WeaponBioGun'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.UseBio'
      Mesh=LodMesh'Botpack.BRifle2Pick'
diff --git a/WFCode/Classes/WFBot.uc b/WFCode/Classes/WFBot.uc
index c210b7e..4186435 100644
--- a/WFCode/Classes/WFBot.uc
+++ b/WFCode/Classes/WFBot.uc
@@ -11,6 +11,16 @@ replication
 		Armor;
 }
 
+function bool IsImmuneTo(class<WFPlayerStatus> StatusClass)
+{
+	local bool bIsImmune;
+
+	if (class<WFPlayerClassInfo>(PCInfo) != None)
+		bIsImmune = class<WFPlayerClassInfo>(PCInfo).static.IsImmuneTo(StatusClass);
+
+	return bIsImmune || (FindInventoryType(class'WFSpawnProtector') != None);
+}
+
 function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
 						Vector momentum, name damageType)
 {
diff --git a/WFCode/Classes/WFChainCannon.uc b/WFCode/Classes/WFChainCannon.uc
index 20bff57..7b6b5d2 100644
--- a/WFCode/Classes/WFChainCannon.uc
+++ b/WFCode/Classes/WFChainCannon.uc
@@ -210,6 +210,7 @@ function Fire( float Value )
 	}
 	if (AmmoType.AmmoAmount > 0)
 	{
+		NotifyFired();
 		GotoState('SpinUp');
 		bPointing=True;
 		bCanClientFire = true;
@@ -232,6 +233,7 @@ function AltFire( float Value )
 	}
 	if (AmmoType.AmmoAmount > 0)
 	{
+		NotifyFired();
 		GotoState('SpinUp');
 		bPointing=True;
 		bCanClientFire = true;
@@ -446,7 +448,7 @@ function ProcessTraceHit(Actor Other, Vector HitLocation, Vector HitNormal, Vect
 		{
 			dscale = 1.0 - ((dist-EffectiveRange)/(MinDamageRange-EffectiveRange));
 			dmgamt = int(FClamp(float(rndDam)*dscale, MinDamage, rndDam));
-			log("-- dist: "$dist$"   dscale: "$dscale$"   rdnDam: "$rndDam$"   dmgamt: "$dmgamt);
+			//log("-- dist: "$dist$"   dscale: "$dscale$"   rdnDam: "$rndDam$"   dmgamt: "$dmgamt);
 		}
 		else dmgamt = rndDam;
 		mo = FClamp(650.0*(1.0 - (dist/2500.0)), 275.0, 650.0);
@@ -769,7 +771,7 @@ defaultproperties
      PickupViewMesh=LodMesh'WFMedia.chainpick'
      ThirdPersonMesh=LodMesh'WFMedia.chainthird'
      ThirdPersonScale=1.600000
-     StatusIcon=Texture'Botpack.Icons.UseMini'
+     StatusIcon=Texture'WFMedia.WeaponMegaChainCannon'
      bMuzzleFlashParticles=True
      MuzzleFlashStyle=STY_Translucent
      MuzzleFlashMesh=LodMesh'Botpack.MuzzFlash3'
diff --git a/WFCode/Classes/WFCloakBlurEffect.uc b/WFCode/Classes/WFCloakBlurEffect.uc
index 832aa9a..340d183 100644
--- a/WFCode/Classes/WFCloakBlurEffect.uc
+++ b/WFCode/Classes/WFCloakBlurEffect.uc
@@ -1,6 +1,6 @@
 class WFCloakBlurEffect extends WFMotionBlurEffect;
 
-function InitFor(actor Other)
+simulated function InitFor(actor Other)
 {
 	Mesh = Other.Mesh;
 	Fatness = Other.Fatness;
diff --git a/WFCode/Classes/WFCloakMotionBlur.uc b/WFCode/Classes/WFCloakMotionBlur.uc
index b05e16e..46d7ded 100644
--- a/WFCode/Classes/WFCloakMotionBlur.uc
+++ b/WFCode/Classes/WFCloakMotionBlur.uc
@@ -2,12 +2,17 @@ class WFCloakMotionBlur extends WFMotionBlurGenerator;
 
 simulated function Tick(float DeltaTime)
 {
-	super.Tick(DeltaTime);
-
 	Mesh = Owner.Mesh;
 	Texture = Texture'JDomN0';
 	PrePivot = Owner.PrePivot;
 	DrawScale = Owner.DrawScale;
+
+	super.Tick(DeltaTime);
+}
+
+simulated function bool ShouldCreateEffect()
+{
+	return !bHidden && (VSize(Owner.Velocity) > 10.0);
 }
 
 defaultproperties
diff --git a/WFCode/Classes/WFCloaker.uc b/WFCode/Classes/WFCloaker.uc
index 2bb9f38..11e6f46 100644
--- a/WFCode/Classes/WFCloaker.uc
+++ b/WFCode/Classes/WFCloaker.uc
@@ -1,16 +1,22 @@
 //=============================================================================
 // WFCloaker.
 //=============================================================================
-class WFCloaker extends TournamentPickup;
+class WFCloaker extends WFPickup;
 
 var() int MaxCharge;
 var() int MinChargeToActivate;
+var() int ReChargeRate;
 
 var WFCloakEffect MyEffect;
 var effects MotionEffect;
 var bool bFadeIn;
 var int ActivateDelay;
 
+var bool bPlayerMoving;
+var bool bMovementDrainOnly;
+
+var int WeaponCost, GrenadeCost;
+
 function PreBeginPlay()
 {
 	bAutoActivate = false;
@@ -44,15 +50,15 @@ function Timer()
 {
 	if (ActivateDelay > 0)
 		ActivateDelay--;
-	/*if (!bActive)
-		Charge = Min(Charge + 1, MaxCharge);
+	if (!bActive)
+		Charge = Min(Charge + ReChargeRate, MaxCharge);
 	else
 	{
-		Charge--;
+		if (!bMovementDrainOnly || bPlayerMoving)
+			Charge = Max(Charge - 1, 0);
 		Pawn(Owner).Visibility = 10;
-		if (Charge <= 0)
-			Activate();
-	}*/
+	}
+	bPlayerMoving = false;
 }
 
 state Activated
@@ -60,7 +66,8 @@ state Activated
 	function BeginState()
 	{
 		bActive = true;
-		Owner.PlaySound(ActivateSound,,12.0);
+		if (Owner != None)
+			Owner.PlaySound(ActivateSound,,12.0);
 		SetOwnerDisplay();
 		MyEffect.FadeOut();
 		SetTimer(1.0, true);
@@ -101,11 +108,20 @@ state Activated
 			ActivateDelay = 0;
 			Activate();
 		}
-		else if (((pawn(Owner).bFire != 0) || (pawn(Owner).bAltFire != 0))
-			&& !ValidWeapon(pawn(Owner).Weapon))
+		bPlayerMoving = bPlayerMoving || (VSize(Owner.Velocity) > 10);
+		// FIXME - move this notify to WFWeapon
+		//else if (((pawn(Owner).bFire != 0) || (pawn(Owner).bAltFire != 0))
+		//	&& !ValidWeapon(pawn(Owner).Weapon, pawn(Owner).bAltFire != 0))
+		//	PlayerFired(pawn(Owner).Weapon);
+
+		if (Charge == 0)
 		{
-			ActivateDelay = 0;
-			Activate();
+			// render cloak useless vs defences when charge is 0
+			Owner.texture = Texture'JDomN0';
+			Owner.bHidden = false;
+			Owner.ScaleGlow = 0.5;
+			if (pawn(Owner).Visibility == 10)
+				pawn(Owner).Visibility = pawn(Owner).default.Visibility;
 		}
 		else if (VSize(Owner.Velocity) < 50.0)
 			Owner.bHidden = true;
@@ -113,7 +129,7 @@ state Activated
 			Owner.bHidden = false;
 
 		if (MotionEffect != None)
-			MotionEffect.bHidden = !bActive || (bActive && (VSize(Owner.Velocity) < 250.0));
+			MotionEffect.bHidden = !bActive || (bActive && (Charge > 0));
 
 		super.Tick(DeltaTime);
 	}
@@ -139,12 +155,24 @@ state Activated
 		if (PawnOwner.Visibility == 10)
 			PawnOwner.Visibility = PawnOwner.default.Visibility;
 		PawnOwner.SetDefaultDisplayProperties();
+		Owner.ScaleGlow = 1.0; // should be the default
 		if( PawnOwner.Inventory != None )
 			PawnOwner.Inventory.SetOwnerDisplay();
 		MotionEffect.bHidden = True;
 	}
 }
 
+static function bool IsCloaked(pawn Other)
+{
+	return (Other == None) || (Other.bMeshEnviroMap && (Other.Texture == FireTexture'Unrealshare.Belt_fx.Invis'));
+}
+
+static function bool IsHalfCloaked(pawn Other)
+{
+	return (Other == None) || (Other.bMeshEnviroMap && (Other.Texture == Texture'JDomN0'));
+}
+
+
 function bool ValidWeapon(Weapon Other, optional bool bAltFired)
 {
 	if ((Other == None) || Other.IsA('WFTranslocator')
@@ -153,6 +181,37 @@ function bool ValidWeapon(Weapon Other, optional bool bAltFired)
 	return false;
 }
 
+// send this from WFWeapon
+function WeaponFired(Weapon WeaponUsed)
+{
+	local WFMotionBlurEffect e;
+	if (!bActive)
+		return;
+
+	if (ValidWeapon(pawn(Owner).Weapon, pawn(Owner).bAltFire != 0))
+		return; // ok to use this weapon type while cloaked
+
+	e = spawn(class'WFCloakerShootPulse', Owner,, Owner.Location, Owner.Rotation);
+	e.InitFor(owner);
+
+	Charge = Max(Charge - WeaponCost, 0);
+	//Owner.PlaySound(sound'TDisrupt', SLOT_None, 4.0);
+}
+
+function GrenadeThrown(WFGrenadeItem GrenadeUsed)
+{
+	local WFMotionBlurEffect e;
+
+	if (!bActive)
+		return;
+
+	e = spawn(class'WFCloakerShootPulse', Owner,, Owner.Location, Owner.Rotation);
+	e.InitFor(owner);
+
+	Charge = Max(Charge - GrenadeCost, 0);
+	//Owner.PlaySound(sound'TDisrupt', SLOT_None, 4.0);
+}
+
 auto state DeActivated
 {
 	function BeginState()
@@ -162,14 +221,18 @@ auto state DeActivated
 			Owner.PlaySound(DeActivateSound);
 			if (MyEffect != None)
 				MyEffect.FadeIn();
-			ActivateDelay = 2;
+			if (Charge <= 0) // need extra time if charge was all used up
+				ActivateDelay = 5;
+			else ActivateDelay = 2;
 		}
 		SetTimer(1.0, true);
-		MotionEffect.bHidden = True;
+		if (MotionEffect != None)
+			MotionEffect.bHidden = True;
 	}
 
 	function Tick( float DeltaTime )
 	{
+		bPlayerMoving = bPlayerMoving || (VSize(Owner.Velocity) > 10);
 		if ((MyEffect != None) && !(MyEffect.FadeMode == 1))
 		{
 			if (Owner != None)
@@ -189,7 +252,7 @@ auto state DeActivated
 		if (pawn(Owner).PlayerReplicationInfo.HasFlag != None)
 			return;
 
-		//if ((Charge > 0) && (Charge >= MinChargeToActivate))
+		if ((Charge > 0) && (Charge >= MinChargeToActivate))
 			GotoState('Activated');
 	}
 
@@ -241,14 +304,24 @@ function CreateEffect()
 	}
 }
 
+function Tick(float DeltaTime)
+{
+	super.Tick(DeltaTime);
+	bPlayerMoving = bPlayerMoving || (VSize(Owner.Velocity) > 10);
+}
+
 defaultproperties
 {
-     MaxCharge=30
+     MaxCharge=100
      MinChargeToActivate=5
+     RechargeRate=2
+     bMovementDrainOnly=True
+     WeaponCost=5
+     GrenadeCost=10
      bActivatable=True
      bDisplayableInv=True
      PickupViewMesh=LodMesh'Botpack.invis2M'
-     Charge=30
+     Charge=100
      ActivateSound=Sound'UnrealI.Pickups.Invisible'
      DeActivateSound=Sound'UnrealI.Pickups.Invisible'
      RemoteRole=ROLE_DumbProxy
diff --git a/WFCode/Classes/WFCyborg.uc b/WFCode/Classes/WFCyborg.uc
index ed83110..1ff16ed 100644
--- a/WFCode/Classes/WFCyborg.uc
+++ b/WFCode/Classes/WFCyborg.uc
@@ -184,6 +184,7 @@ static function bool IsArmingPlasma(pawn Other)
 
 defaultproperties
 {
+     TranslocatorAmmoUsed=25
      bNoEnforcer=True
      ClassName="Cyborg"
      ClassNamePlural="Cyborgs"
diff --git a/WFCode/Classes/WFDemoMan.uc b/WFCode/Classes/WFDemoMan.uc
index f21adbe..20398b8 100644
--- a/WFCode/Classes/WFDemoMan.uc
+++ b/WFCode/Classes/WFDemoMan.uc
@@ -16,6 +16,7 @@ static function bool IsClientSideCommand(string SpecialString)
 static function PlayerDied(pawn Other, pawn Killer, name damageType, vector HitLocation)
 {
 	local WFGrenFreezeProj g;
+	local WFPipeBombTrigger PBT;
 
 	// remove any active Freeze Grenades
 	foreach Other.AllActors(class'WFGrenFreezeProj', g)
@@ -23,6 +24,13 @@ static function PlayerDied(pawn Other, pawn Killer, name damageType, vector HitL
 		if ((g != None) && !g.bDeleteMe && (g.Instigator == Other))
 			g.Timer(); // make grenades expire early
 	}
+
+	// remove any active Pipebomb Triggers
+	foreach Other.AllActors(class'WFPipeBombTrigger', PBT)
+	{
+		if ((PBT != None) && !PBT.bDeleteMe && (PBT.Instigator == Other))
+			PBT.Destroy();
+	}
 }
 
 static function DoSpecial(pawn Other, string SpecialString, optional name Type)
@@ -37,13 +45,8 @@ static function DoSpecial(pawn Other, string SpecialString, optional name Type)
 		SetTripmine(Other);
 	else if (SpecialString ~= "RemoveMine")
 		RemoveTripmine(Other);
-}
-
-
-static function SetTripmine(pawn Other)
-{
-	//Log("Setting mine");
-	TraceMineWall(Other);
+	else if (Left(SpecialString, 13) ~= "DeployTrigger")
+		DeployPipeTrigger(Other, Right(SpecialString, Len(SpecialString) - 14));
 }
 
 static function RemoveTripmine(pawn Other)
@@ -90,7 +93,7 @@ static function RemoveAllTripmines(pawn Other)
 		if ((WFL != None) && !WFL.bDeleteMe) WFL.Destroy();
 }
 
-static function TraceMineWall(pawn Other)
+static function SetTripmine(pawn Other)
 {
 	local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;
 	local actor HitActor;
@@ -121,6 +124,44 @@ static function TraceMineWall(pawn Other)
 
 }
 
+static function DeployPipeTrigger(pawn Other, string Delay)
+{
+	local vector X, Y, Z;
+	local WFPipeBombTrigger PBT;
+	local float TriggerDelay;
+
+	TriggerDelay = FClamp(float(Delay), 1.0, 3.0);
+	if (Delay == "") Delay = "1";
+
+	foreach Other.AllActors(class'WFPipeBombTrigger', PBT)
+		if ((PBT != None) && (PBT.Instigator == Other))
+			break;
+
+	if ((PBT != None) && !PBT.bCanMove)
+	{
+		Other.ClientMessage("Cannot re-deploy a Proximity Trigger within 2 seconds of deploying on a surface or wall.", 'Critical');
+		return;
+	}
+
+	Other.ClientMessage("Deploying "$delay$" second delay Proximity Trigger.", 'Critical');
+
+	if (PBT != None)
+	{
+		PBT.spawn(class'EnhancedRespawn', PBT,, PBT.Location);
+		PBT.Destroy();
+		PBT = None;
+	}
+
+	PBT = None;
+	GetAxes(Other.ViewRotation,X,Y,Z);
+	PBT = Other.spawn(class'WFPipeBombTrigger', Other,, Other.Location + Other.Eyeheight*Z, Other.ViewRotation);
+	PBT.SetPhysics(PHYS_Falling);
+	PBT.Instigator = Other;
+	PBT.TriggerDelay = TriggerDelay;
+	PBT.OwnerTeam = Other.PlayerReplicationInfo.Team;
+	PBT.Velocity = vector(Other.ViewRotation) * 350 + vect(0,0,1)*100;
+}
+
 defaultproperties
 {
      MaxTripmines=4
diff --git a/WFCode/Classes/WFDemomanHUDMenu.uc b/WFCode/Classes/WFDemomanHUDMenu.uc
index eed07a8..f2e120e 100644
--- a/WFCode/Classes/WFDemomanHUDMenu.uc
+++ b/WFCode/Classes/WFDemomanHUDMenu.uc
@@ -4,21 +4,29 @@ class WFDemomanHUDMenu extends WFClassHUDMenu;
 function ProcessSelection(int Selection)
 {
 	DisplayTimeLeft = DisplayTime;
+
 	//Log("procsel"@Selection);
+	if (ChildMenu != none)
+	{
+		ChildMenu.ProcessSelection(Selection);
+		return;
+	}
+
 	switch (Selection)
 	{
 		case 0:
 			break;
 		case 1:
 			PlayerOwner.Special("setmine");
-			//SetLaserDefense();
 			CloseMenu();
 			break;
 		case 2:
 			PlayerOwner.Special("removemine");
-			//RemoveLaserDefense();
 			CloseMenu();
 			break;
+		case 3:
+			CreateChildMenu(class'WFDemomanTriggerHUDMenu');
+			break;
 		case 10:
 			CloseMenu();
 			break;
@@ -29,6 +37,7 @@ defaultproperties
 {
      MenuOptions(0)="Set Laser Tripmine"
      MenuOptions(1)="Remove Laser Tripmine"
+     MenuOptions(2)="Deploy Prox Trigger"
      MenuOptions(8)=" "
      MenuOptions(9)="Close Menu"
      MenuTitle="[ - Demoman Options - ]"
@@ -37,6 +46,6 @@ defaultproperties
      bUseColors=True
      MenuOptionColors(3)=(R=128,G=128,B=128)
      MenuOptionColors(4)=(R=128,G=128,B=128)
-     NumOptions=4
+     NumOptions=5
      DisplayTime=10
 }
diff --git a/WFCode/Classes/WFDisguise.uc b/WFCode/Classes/WFDisguise.uc
index 910662e..b58df3e 100644
--- a/WFCode/Classes/WFDisguise.uc
+++ b/WFCode/Classes/WFDisguise.uc
@@ -82,7 +82,7 @@ function ChangeDisguise(byte NewTeam, class<WFS_PlayerClassInfo> NewPCI)
 		class'WFPlayerClassInfo'.static.SetClassName(pawn(Owner), NewPCI.default.ClassName);
 	}
 
-	UpdateMeshInfo();
+	UpdateDPMSInfo();
 
 	if (bChangedClass || bChangedTeam)
 	{
@@ -109,22 +109,31 @@ function Timer()
 	//Owner.SetDefaultDisplayProperties();
 }
 
-function UpdateMeshInfo()
+function UpdateDPMSInfo()
 {
 	local class<WFD_DPMSMeshInfo> MI;
 
-	// update the WFD_DPMSMeshInfo
 	if (PlayerOwner != None)
 	{
+		// update the WFD_DPMSMeshInfo
 		MI = DisguisePCI.default.MeshInfo;
 		PlayerOwner.MeshInfo = DisguisePCI.default.MeshInfo;
 		PlayerOwner.Mesh = MI.default.PlayerMesh;
+		// update the WFD_DPMSSoundInfo
+		if (DisguisePCI.default.SoundInfo != None)
+			PlayerOwner.SoundInfo = DisguisePCI.default.SoundInfo;
+		else PlayerOwner.SoundInfo = MI.default.DefaultSoundClass;
 	}
 	else if (BotOwner != None)
 	{
+	// update the WFD_DPMSMeshInfo
 		MI = DisguisePCI.default.AltMeshInfo;
 		BotOwner.MeshInfo = DisguisePCI.default.AltMeshInfo;
 		BotOwner.Mesh = MI.default.PlayerMesh;
+		// update the WFD_DPMSSoundInfo
+		if (DisguisePCI.default.SoundInfo != None)
+			BotOwner.SoundInfo = DisguisePCI.default.SoundInfo;
+		else BotOwner.SoundInfo = MI.default.DefaultSoundClass;
 	}
 
 	MI.static.SetMultiSkin(
@@ -160,7 +169,7 @@ function RemoveDisguise(optional bool bNoMessage)
 	DisguisePCI = class'WFS_PlayerClassInfo'.static.GetPCIFor(pawn(Owner));
 	DisguiseTeam = pawn(Owner).PlayerReplicationInfo.Team;
 	class'WFPlayerClassInfo'.static.SetClassName(pawn(Owner), DisguisePCI.default.ClassName);
-	UpdateMeshInfo();
+	UpdateDPMSInfo();
 
 	if (!bNoMessage && (PawnOwner != None))
 		PawnOwner.ClientMessage(ExpireMessage, 'CriticalEvent');
@@ -236,6 +245,9 @@ state Disguised
 		}
 	}
 
+	function WeaponFired(Weapon WeaponUsed) { if (!ValidWeaponType(WeaponUsed)) RemoveDisguise(); }
+	function GrenadeThrown(WFGrenadeItem GrenadeUsed) { RemoveDisguise(); }
+
 	function EndState()
 	{
 		ClearStatusFlag();
@@ -243,6 +255,9 @@ state Disguised
 	}
 }
 
+function WeaponFired(Weapon WeaponUsed);
+function GrenadeThrown(WFGrenadeItem GrenadeUsed);
+
 function Destroyed()
 {
 	if (bDisguised)
diff --git a/WFCode/Classes/WFEnforcer.uc b/WFCode/Classes/WFEnforcer.uc
index 8d66d58..dc3b95c 100644
--- a/WFCode/Classes/WFEnforcer.uc
+++ b/WFCode/Classes/WFEnforcer.uc
@@ -320,6 +320,7 @@ function Fire(float Value)
 	}
 	if ( AmmoType.UseAmmo(1) )
 	{
+		NotifyFired();
 		GotoState('NormalFire');
 		bCanClientFire = true;
 		bPointing=True;
@@ -374,6 +375,7 @@ function AltFire( float Value )
 	}
 	if (AmmoType.AmmoAmount>0)
 	{
+		NotifyFired();
 		if ( SlaveEnforcer != None )
 			Pawn(Owner).PlayRecoil(3 * FiringSpeed);
 		else if ( !bIsSlave )
@@ -603,6 +605,7 @@ Begin:
 Repeater:
 	if (AmmoType.UseAmmo(1))
 	{
+		NotifyFired();
 		FlashCount++;
 		if ( SlaveEnforcer != None )
 			Pawn(Owner).PlayRecoil(3 * FiringSpeed);
@@ -810,10 +813,10 @@ defaultproperties
      AIRating=0.250000
      RefireRate=0.800000
      AltRefireRate=0.870000
-     FireSound=Sound'Botpack.enforcer.E_Shot'
+     FireSound=Sound'Botpack.Enforcer.E_Shot'
      AltFireSound=Sound'UnrealShare.AutoMag.shot'
-     CockingSound=Sound'Botpack.enforcer.Cocking'
-     SelectSound=Sound'Botpack.enforcer.Cocking'
+     CockingSound=Sound'Botpack.Enforcer.Cocking'
+     SelectSound=Sound'Botpack.Enforcer.Cocking'
      DeathMessage="%k riddled %o full of holes with the %w."
      NameColor=(R=200,G=200)
      bDrawMuzzleFlash=True
@@ -832,7 +835,7 @@ defaultproperties
      PlayerViewMesh=LodMesh'Botpack.AutoML'
      PickupViewMesh=LodMesh'Botpack.MagPick'
      ThirdPersonMesh=LodMesh'Botpack.AutoHand'
-     StatusIcon=Texture'Botpack.Icons.UseAutoM'
+     StatusIcon=Texture'WFMedia.WeaponEnforcer'
      bMuzzleFlashParticles=True
      MuzzleFlashStyle=STY_Translucent
      MuzzleFlashMesh=LodMesh'Botpack.muzzEF3'
diff --git a/WFCode/Classes/WFEngineerHUDInfo.uc b/WFCode/Classes/WFEngineerHUDInfo.uc
index a0729db..63021b7 100644
--- a/WFCode/Classes/WFEngineerHUDInfo.uc
+++ b/WFCode/Classes/WFEngineerHUDInfo.uc
@@ -1,46 +1,65 @@
 //=============================================================================
 // WFEngineer.
 //=============================================================================
-class WFEngineerHUDInfo extends WFHUDInfo;
+class WFEngineerHUDInfo extends WFCustomHUDInfo;
 
 var() texture CustomIconTexture;
 
 // could make this a general use function and move to WFHUDInfo and WFITSHUDInfo
 simulated function DrawStatus(out byte bOverrideFunction, Canvas Canvas)
 {
-	local bool bHasDoll;
-	local float X, Y, StatScale;
-	local int IconValue;
+	local byte         Style;
+	local color        DigitBackground;
+	local texture      DigitTexure;
+	local int          ResourceAmount;
+	local WFCustomHUD MyOwnerHUD;
 
-	IconValue = GetIconValue();
+	MyOwnerHUD = WFCustomHUD( OwnerHUD );
 
-	if (!OwnerHUD.bHideStatus)
+  // Preserve the current style
+  Style = Canvas.Style;
+
+  Canvas.SetPos( Canvas.ClipX - ( 128 * MyOwnerHUD.MyStatusScale ),
+	               68 * MyOwnerHUD.MyStatusScale );
+  MyOwnerHUD.DrawPanel( Canvas,
+                        MyOwnerHUD.EPanel.PLeft,
+                        ERenderStyle.STY_Modulated,
+		 	  							  32, 32, MyOwnerHUD.HUDColor,
+                        MyOwnerHUD.Opacity,
+                        MyOwnerHUD.MyStatusScale );
+  MyOwnerHUD.DrawPanel( Canvas,
+                        MyOwnerHUD.EPanel.PMiddle,
+                        ERenderStyle.STY_Modulated,
+		 								    96, 32, MyOwnerHUD.HUDColor,
+                        MyOwnerHUD.Opacity,
+                        MyOwnerHUD.MyStatusScale );
+
+  Canvas.DrawColor = MyOwnerHUD.HUDColor;
+	 Canvas.Style = MyOwnerHUD.MySolidStyle;
+
+  Canvas.SetPos( Canvas.ClipX - ( 110 * MyOwnerHUD.MyStatusScale ),
+	               68 * MyOwnerHUD.MyStatusScale );
+  Canvas.DrawTile( Texture'ResourceIcon', 32 * MyOwnerHUD.MyStatusScale,
+	                                        32 * MyOwnerHUD.MyStatusScale,
+	                                        0, 0, 32.0, 32.0);
+
+	ResourceAmount = GetIconValue();
+  if( ResourceAmount < 0 )
 	{
-		bHasDoll = !(Canvas.ClipX < 400);
-		if (bHasDoll)
-			StatScale = OwnerHUD.Scale * OwnerHUD.StatusScale;
+	  ResourceAmount = 0;
 	}
 
-	// draw the hud icon
-	Canvas.DrawColor = OwnerHUD.HUDColor;
-	if ( OwnerHUD.bHideStatus && OwnerHUD.bHideAllWeapons )
-	{
-		//X = 0.5 * Canvas.ClipX;
-		//Y = Canvas.ClipY - 128 * OwnerHUD.Scale;
-		X = Canvas.ClipX - 128 * OwnerHUD.Scale;
-		Y = 0;
-	}
-	else
-	{
-		X = Canvas.ClipX - 128 * StatScale - 140 * OwnerHUD.Scale;
-		Y = 128 * OwnerHUD.Scale; // Y=0 for armor, Y=64 for health
-	}
-	Canvas.SetPos(X,Y);
-	Canvas.DrawTile(CustomIconTexture, 128*OwnerHUD.Scale, 64*OwnerHUD.Scale, 0, 0, 128.0, 64.0);
+  Canvas.SetPos( Canvas.ClipX - ( 72 * MyOwnerHUD.MyStatusScale ),
+	               68 * MyOwnerHUD.MyStatusScale );
+  MyOwnerHUD.DrawDigits( Canvas,
+	              ResourceAmount,
+                3,
+	              MyOwnerHUD.HUDColor,
+								MyOwnerHUD.HUDBackgroundColor,
+                MyOwnerHUD.MySolidStyle,
+                ERenderStyle.STY_Translucent,
+								MyOwnerHUD.MyStatusScale);
 
-	// draw the value for the icon
-	Canvas.DrawColor = OwnerHUD.WhiteColor;
-	OwnerHUD.DrawBigNum(Canvas, Max(0,IconValue), X + 4 * OwnerHUD.Scale, Y + 16 * OwnerHUD.Scale, 1);
 }
 
 function int GetIconValue()
diff --git a/WFCode/Classes/WFFieldMedic.uc b/WFCode/Classes/WFFieldMedic.uc
index 19d3c4d..fb134ac 100644
--- a/WFCode/Classes/WFFieldMedic.uc
+++ b/WFCode/Classes/WFFieldMedic.uc
@@ -3,6 +3,21 @@
 //=============================================================================
 class WFFieldMedic extends WFPlayerClassInfo;
 
+static function ModifyPlayer(pawn Other)
+{
+	local float SpeedScaling;
+
+	if (DeathMatchPlus(Other.Level.Game).bMegaSpeed)
+		SpeedScaling = 1.4;
+	else SpeedScaling = 1.0;
+
+	Other.GroundSpeed = (Other.default.GroundSpeed * SpeedScaling) * 1.1;
+	Other.WaterSpeed = (Other.default.WaterSpeed * SpeedScaling) * 1.1;
+	Other.AirSpeed = (Other.default.AirSpeed * SpeedScaling) * 1.1;
+	Other.AccelRate = (Other.default.AccelRate * SpeedScaling) * 1.1;
+	Other.Mass = Other.default.Mass * 0.9;
+}
+
 static function bool IsImmuneTo(class<WFPlayerStatus> StatusClass)
 {
 	if ((StatusClass == class'WFStatusInfected') || (StatusClass == class'WFStatusOnFire'))
@@ -97,7 +112,6 @@ defaultproperties
      MeshInfo=Class'WFSystem.WFD_TFemale1MeshInfo'
      AltMeshInfo=Class'WFSystem.WFD_TFemale1BotMeshInfo'
      DefaultInventory=Class'WFCode.WFFieldMedicInv'
-     ExtendedHUD=Class'WFSystem.WFS_CTFHUDInfo'
      HUDMenu=Class'WFCode.WFFieldMedicMenu'
      Armor=50
      ClassDescription="WFCode.WFClassHelpFieldMedic"
diff --git a/WFCode/Classes/WFFlag.uc b/WFCode/Classes/WFFlag.uc
index c223edf..76bc309 100644
--- a/WFCode/Classes/WFFlag.uc
+++ b/WFCode/Classes/WFFlag.uc
@@ -95,6 +95,10 @@ state Dropped
 					}
 					else if ( Holder.IsA('TournamentPlayer') && TournamentPlayer(Holder).bAutoTaunt )
 						Holder.SendTeamMessage(None, 'OTHER', 8, 10);
+
+					// send flag collected event
+					class'WFPlayerClassInfo'.static.SendEvent(pawn(Other), "flag_pickedup_own");
+
 					BroadcastLocalizedMessage( class'CTFMessage', 4, Holder.PlayerReplicationInfo, None, CTFGame(Level.Game).Teams[Team] );
 					if (Level.Game.WorldLog != None)
 						Level.Game.WorldLog.LogSpecialEvent("flag_pickedup", Holder.PlayerReplicationInfo.PlayerID, CTFGame(Level.Game).Teams[Team].TeamIndex);
@@ -116,6 +120,9 @@ state Dropped
 				}
 				else if ( Holder.IsA('TournamentPlayer') && TournamentPlayer(Holder).bAutoTaunt )
 					Holder.SendTeamMessage(None, 'OTHER', 2, 10);
+
+				// send flag collected event
+				class'WFPlayerClassInfo'.static.SendEvent(pawn(Other), "flag_pickedup");
 			}
 			BroadcastLocalizedMessage( class'CTFMessage', 4, Holder.PlayerReplicationInfo, None, CTFGame(Level.Game).Teams[Team] );
 			if (Level.Game.WorldLog != None)
diff --git a/WFCode/Classes/WFFlakCannon.uc b/WFCode/Classes/WFFlakCannon.uc
index 2c9af82..b0ed685 100644
--- a/WFCode/Classes/WFFlakCannon.uc
+++ b/WFCode/Classes/WFFlakCannon.uc
@@ -113,6 +113,7 @@ function Fire( float Value )
 	}
 	if (AmmoType.UseAmmo(1))
 	{
+		NotifyFired();
 		bCanClientFire = true;
 		bPointing=True;
 		Start = Owner.Location + CalcDrawOffset();
@@ -173,6 +174,7 @@ function AltFire( float Value )
 	}
 	if (AmmoType.UseAmmo(1))
 	{
+		NotifyFired();
 		Pawn(Owner).PlayRecoil(FiringSpeed);
 		bPointing=True;
 		bCanClientFire = true;
diff --git a/WFCode/Classes/WFFlameProj.uc b/WFCode/Classes/WFFlameProj.uc
index fca3889..51cbc2f 100644
--- a/WFCode/Classes/WFFlameProj.uc
+++ b/WFCode/Classes/WFFlameProj.uc
@@ -1,6 +1,7 @@
 class WFFlameProj expands WFAnimatedProj;
 
 var float FinalDrawScale;
+var float FadeCoef;
 
 function PostBeginPlay()
 {
@@ -35,6 +36,9 @@ simulated function ZoneChange(zoneinfo NewZone)
 simulated function Tick(float DeltaTime)
 {
 	DrawScale = default.DrawScale + ( (FinalDrawScale - default.DrawScale)*(1.0 - (LifeSpan/default.LifeSpan)) );
+	if (LifeSpan > FadeCoef*default.LifeSpan)
+		ScaleGlow = default.ScaleGlow;
+	else ScaleGlow = default.ScaleGlow*(LifeSpan/(FadeCoef*default.LifeSpan));
 	super.Tick(DeltaTime);
 }
 
@@ -50,7 +54,8 @@ auto state Flying
 		local bool bGiveStatus;
 		local class<WFPlayerClassInfo> PCI;
 
-		if ((Level.NetMode == NM_Client) || (Role != ROLE_Authority) || (Other == Instigator))
+		if ((Level.NetMode == NM_Client) || (Role != ROLE_Authority) || (Other == Instigator)
+			|| (damage <= 0))
 			return;
 
 		Other.TakeDamage(Damage, Instigator, HitLocation, vect(0,0,0), 'OnFireStatus');
@@ -61,8 +66,10 @@ auto state Flying
 			If ( Other!=Instigator && WFFlameProj(Other)==None && aPawn != None )
 				if (aPawn.bIsPlayer && (aPawn.Health > 0))
 				{
-					PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
-					bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+					//WFP = WFPlayer(aPawn);
+					//PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
+					//bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+					bGiveStatus = !class'WFPlayerClassInfo'.static.PawnIsImmuneTo(aPawn, class'WFStatusOnFire');
 
 					if (bGiveStatus && (aPawn.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team))
 					{
@@ -87,6 +94,7 @@ auto state Flying
 defaultproperties
 {
      FinalDrawScale=1.000000
+     FadeCoef=0.330000
      TextureList(0)=Texture'UnrealShare.s_Exp001'
      TextureList(1)=Texture'UnrealShare.s_Exp002'
      TextureList(2)=Texture'UnrealShare.s_Exp003'
diff --git a/WFCode/Classes/WFFlameThrower.uc b/WFCode/Classes/WFFlameThrower.uc
index 6c08b5c..07693c8 100644
--- a/WFCode/Classes/WFFlameThrower.uc
+++ b/WFCode/Classes/WFFlameThrower.uc
@@ -15,6 +15,7 @@ function Fire( float Value )
 	}
 	if ( (GetStateName() == 'AltFiring') || AmmoType.UseAmmo(1) )
 	{
+		NotifyFired();
 		GotoState ('NormalFire');
 		bPointing=True;
 		bCanClientFire = true;
@@ -185,7 +186,7 @@ state ClientFiring
 
 defaultproperties
 {
-     AmmoName=Class'Botpack.BioAmmo'
+     AmmoName=Class'WFCode.WFFlameThrowerAmmo'
      PickupAmmoCount=25
      FireOffset=(X=15.000000,Y=-9.000000,Z=-16.000000)
      DeathMessage="%o drank a glass of %k's dripping green load."
@@ -197,6 +198,7 @@ defaultproperties
      PlayerViewMesh=LodMesh'UnrealI.BRifle'
      PickupViewMesh=LodMesh'UnrealI.BRiflePick'
      ThirdPersonMesh=LodMesh'UnrealI.BRifle3'
+     StatusIcon=Texture'WFMedia.WeaponFlameThrower'
      Icon=Texture'Botpack.Icons.UseBio'
      Mesh=LodMesh'UnrealI.BRiflePick'
      bNoSmooth=False
diff --git a/WFCode/Classes/WFFlameThrowerFlameGen.uc b/WFCode/Classes/WFFlameThrowerFlameGen.uc
index 7339ea6..2fcaf98 100644
--- a/WFCode/Classes/WFFlameThrowerFlameGen.uc
+++ b/WFCode/Classes/WFFlameThrowerFlameGen.uc
@@ -1,6 +1,6 @@
 class WFFlameThrowerFlameGen extends Projectile;
 
-var class<projectile> FlameClass;
+var class<projectile> FlameClass, AltFlameClass;
 var bool bCenter, bRight;
 var float AimError, NewError;
 var rotator AimRotation;
@@ -17,23 +17,49 @@ replication
 		AimError, NewError, AimRotation;
 }
 
+
 auto simulated state GenerateFlames
 {
+	function bool IsDedicatedServer()
+	{
+		return (Level.NetMode == NM_DedicatedServer);
+	}
 Begin:
-	UpdateLocation();
-	SpawnFlameProj();
-	Sleep(FlameRate);
-	goto 'Begin';
+	if (Level.bHighDetailMode)
+	{
+		UpdateLocation(FlameRate/3.0);
+		SpawnFlameProj();
+		Sleep(FlameRate/3.0);
+		UpdateLocation(FlameRate/3.0);
+		if (!Level.bDropDetail && !IsDedicatedServer())
+			SpawnFlameProj(true);
+		Sleep(FlameRate/3.0);
+		UpdateLocation(FlameRate/3.0);
+		if (!Level.bDropDetail && !IsDedicatedServer())
+			SpawnFlameProj(true);
+		Sleep(FlameRate/3.0);
+	}
+	else
+	{
+		UpdateLocation(FlameRate/2.0);
+		SpawnFlameProj();
+		Sleep(FlameRate/2.0);
+		UpdateLocation(FlameRate/2.0);
+		if (!Level.bDropDetail && !IsDedicatedServer())
+			SpawnFlameProj(true);
+		Sleep(FlameRate/2.0);
+	}
+	Goto('Begin');
 }
 
-simulated function UpdateLocation()
+simulated function UpdateLocation(float DeltaTime)
 {
 	local vector X,Y,Z, AimSpot, DrawOffset, AimStart;
 	local int YawErr;
 	local float dAdjust;
 	local Bot MyBot;
-	local float DeltaTime;
-	DeltaTime = FlameRate; // the delay between flames
+	//local float DeltaTime;
+	//DeltaTime = FlameRate; // the delay between flames
 
 	if (Instigator != None)
 	{
@@ -130,24 +156,32 @@ simulated function UpdateLocation()
 				FireOffset.Y = -1 * Default.FireOffset.Y;
 		}
 		DrawOffset = Owner.Location + DrawOffset + FireOffset.X * X + FireOffset.Y * Y + FireOffset.Z * Z;
-		SetLocation(DrawOffset);
+		if (Location != DrawOffset)
+			SetLocation(DrawOffset);
 	}
 }
 
-simulated function SpawnFlameProj()
+simulated function SpawnFlameProj(optional bool bAltFlame)
 {
 	local effects e;
 	local projectile p;
+	local vector X, Y, Z, vel;
+
 	if (Instigator != None)
 	{
 		if (Role == ROLE_Authority)
 			Instigator.MakeNoise(Instigator.SoundDampening);
+		GetAxes(Instigator.ViewRotation, X, Y, Z);
+		vel = X * VSize(Instigator.Velocity) * (normal(Instigator.Velocity) dot X);
+		if (VSize(vel) > Instigator.GroundSpeed)
+			vel *= Instigator.GroundSpeed/VSize(vel);
 		//AdjustedAim = Instigator.AdjustAim(FlameSpeed, Location, AimError, True, True);
 		if (!Region.Zone.bWaterZone)
 		{
-			p = Spawn(FlameClass,,, Location,Instigator.ViewRotation);
+			if (bAltFlame) p = Spawn(AltFlameClass,,, Location,Instigator.ViewRotation);
+			else p = Spawn(FlameClass,,, Location,Instigator.ViewRotation);
 			if (p != None)
-				p.Velocity = p.Speed*vector(Instigator.ViewRotation) + Instigator.Velocity;
+				p.Velocity = p.Speed*vector(Instigator.ViewRotation) + vel;
 		}
 		else
 		{
@@ -160,6 +194,7 @@ simulated function SpawnFlameProj()
 defaultproperties
 {
      FlameClass=Class'WFCode.WFFlameProj'
+     AltFlameClass=Class'WFCode.WFFlameProjAlt'
      FireOffset=(X=15.000000,Y=-9.000000,Z=-16.000000)
      FlameRate=0.070000
      bNetTemporary=False
diff --git a/WFCode/Classes/WFGame.uc b/WFCode/Classes/WFGame.uc
index a6f98e5..5b0932c 100644
--- a/WFCode/Classes/WFGame.uc
+++ b/WFCode/Classes/WFGame.uc
@@ -37,6 +37,8 @@ var const int FRS_TouchReturn; // players can touch their flag to return it
 var const int FRS_CarryReturn; // players must carry their own flag back to base to return it
 
 var() config float FlagReturnTime; // time before flag auto-returns
+var() config float DefendRadius; //radius in which person defends flag
+var() config float FlagRunnerDefendRadius; //radius in which person defends ithe flag runner
 
 // TODO: add these to the GRI
 var() config bool bAutoTeamTimer; // players must choose a team within AutoTeamTime seconds
@@ -55,9 +57,84 @@ var() class<WFS_WindowDisplayInfo> TeamPasswordDialogClass[4];
 var config bool bRefStartGame; // referee must start the game when in tournament mode
 var WFRefereeInfo RefInfo;
 
+var() config int MaxLoginAttempts;
+var() config float SpawnProtectionTime;
+
 // score related
 var int KilledFlagCarrierBonus;
 
+// MiscScoreArray index usage
+var() byte INDEX_FlagCaps;
+var() byte INDEX_FlagDefends;
+var() byte INDEX_FlagCarrierKills;
+var() byte INDEX_FlagCarrierDefends;
+var() byte INDEX_FlagReturns;
+var() byte INDEX_Frags;
+
+function PostBeginPlay()
+{
+	local int i;
+
+	super.PostBeginPlay();
+
+	for (i=0;i<4;i++)
+	{
+		// remove the old UT team info
+		Teams[i].Size = 0;
+		Teams[i].Score = 0;
+		Teams[i].TeamName = "";
+		Teams[i].TeamIndex = -1;
+		Teams[i].Destroy();
+		Teams[i] = None;
+
+		// create the WFTeamInfo classes
+		Teams[i] = Spawn(class'WFTeamInfo');
+		Teams[i].Size = 0;
+		Teams[i].Score = 0;
+		Teams[i].TeamName = TeamNames[i];
+		Teams[i].TeamIndex = i;
+		TournamentGameReplicationInfo(GameReplicationInfo).Teams[i] = Teams[i];
+	}
+}
+
+function AdminLogin( PlayerPawn P, string Password )
+{
+	local WFPlayer WFP;
+	local float logintime;
+
+	WFP = WFPlayer(P);
+	if ((WFP == None) || WFP.bAdminLoginDisabled || WFP.bAdmin)
+		return;
+
+	if (WFP.NumAdminLogins == 0)
+	{
+		WFP.NumAdminLogins++;
+		WFP.FirstAdminLoginTime = Level.TimeSeconds;
+	}
+	else
+		WFP.NumAdminLogins++;
+
+	super.AdminLogin(P, Password);
+
+	if (P.bAdmin)
+	{
+		WFP.NumAdminLogins = 0;
+		WFP.FirstAdminLoginTime = 0.0;
+	}
+	else
+	{
+		// check to see if player is flooding to try to gain the password
+		logintime = Level.TimeSeconds - WFP.FirstAdminLoginTime;
+		if (WFP.NumAdminLogins > MaxLoginAttempts)
+		{
+			WFP.bAdminLoginDisabled = true;
+			WFP.NumAdminLogins = 0;
+			WFP.FirstAdminLoginTime = 0.0;
+			Log("INFO: ADMINLOGIN: "$WFP.PlayerReplicationInfo.PlayerName$" (IP: "$WFP.GetPlayerNetworkAddress()$") failed to log in within "$MaxLoginAttempts$" attempts, ADMIN login disabled for this player");
+		}
+	}
+}
+
 function PreBeginPlay()
 {
 	super.PreBeginPlay();
@@ -66,6 +143,18 @@ function PreBeginPlay()
 		RefInfo = spawn(class'WFRefereeInfo');
 }
 
+event InitGame( string Options, out string Error )
+{
+	Super.InitGame(Options, Error);
+	MaxCommanders = 0;
+}
+
+function InitGameReplicationInfo()
+{
+	super.InitGameReplicationInfo();
+	WFGameGRI(GameReplicationInfo).FlagReturnStyle = FlagReturnStyle;
+}
+
 function bool CheckForMapData()
 {
 	return true; // use default map setup class: WFGameMapSetupInfo
@@ -92,11 +181,76 @@ function InitClassLists()
 
 event PostLogin( playerpawn NewPlayer )
 {
+	local string TimeString;
+
 	Super.PostLogin(NewPlayer);
+
+	GetTimeStamp(TimeString);
+
+	Log("=== PLAYER LOGED IN ===");
+	Log("Login Name: "$NewPlayer.PlayerReplicationInfo.PlayerName);
+	Log("Time: "$TimeString);
+	Log("IP Address: "$NewPlayer.GetPlayerNetworkAddress());
+	Log("=======================");
+
 	WFPlayer(NewPlayer).bLoginComplete = true;
 	WFPlayer(NewPlayer).RefInfo = RefInfo;
 }
 
+function ChangeName(Pawn Other, string S, bool bNameChange)
+{
+	local string oldName, TimeString;
+
+	oldname = other.playerReplicationInfo.PlayerName;
+	super.ChangeName(Other, S, bNameChange);
+
+	if (Other.IsA('WFPlayer') && WFPlayer(Other).bLoginComplete
+		&& (oldname != other.playerReplicationInfo.PlayerName))
+	{
+		GetTimeStamp(TimeString);
+		Log("=== PLAYER CHANGED NAME ===");
+		Log("Old Name: "$oldname);
+		Log("New Name: "$other.PlayerReplicationInfo.PlayerName);
+		Log("Time: "$TimeString);
+		Log("IP Address: "$playerpawn(other).GetPlayerNetworkAddress());
+		Log("=======================");
+	}
+}
+
+function string GetGameTime()
+{
+	local string TimeStamp;
+
+	TimeStamp = string(Level.Year);
+
+	if (Level.Month < 10)
+		TimeStamp = TimeStamp$"/0"$Level.Month;
+	else
+		TimeStamp = TimeStamp$"/"$Level.Month;
+
+	if (Level.Day < 10)
+		TimeStamp = TimeStamp$"/0"$Level.Day;
+	else
+		TimeStamp = TimeStamp$"/"$Level.Day;
+
+	if (Level.Hour < 10)
+		TimeStamp = TimeStamp$" 0"$Level.Hour;
+	else
+		TimeStamp = TimeStamp$" "$Level.Hour;
+
+	if (Level.Minute < 10)
+		TimeStamp = TimeStamp$":0"$Level.Minute;
+	else
+		TimeStamp = TimeStamp$":"$Level.Minute;
+
+	if (Level.Second < 10)
+		TimeStamp = TimeStamp$":0"$Level.Second;
+	else
+		TimeStamp = TimeStamp$":"$Level.Second;
+
+	return TimeStamp;
+}
+
 function int ReduceDamage(int Damage, name DamageType, pawn injured, pawn instigatedBy)
 {
 	local int injuredTeam, instigatingTeam;
@@ -153,6 +307,12 @@ function bool CanChangeTeam(pawn Other, int NewTeam)
 	if ((WFP == None) || !WFP.bLoginComplete)
 		return true;
 
+	if (WFP.bLoginComplete && (WFP.PlayerReplicationInfo.Team == NewTeam))
+	{
+		WFP.ClientMessage("You are already on that team.", 'CriticalEvent', true);
+		return false;
+	}
+
 	if (NewTeam == 255)
 	{
 		for (i=0; i<MaxTeams; i++)
@@ -191,6 +351,26 @@ function Killed( pawn Killer, pawn Other, name damageType )
 {
 	local WFBackPack pack;
 	local float speed;
+	local WF_PRI WFPRI;
+	local WF_BotPRI WFBotPRI;
+	local WFCustomHUD MyHUD;
+  local int i, flagteam;
+	local WFFlag Flag;
+	local TournamentGameReplicationInfo OwnerGame;
+	local bool bPointGiven;
+	local pawn aPawn;
+	local PlayerReplicationInfo HolderPRI;
+  local vector FlagLocation;
+	local bool bFlagLOS;
+
+	// send some events
+	if (Other.PlayerReplicationInfo.HasFlag != None)
+	{
+		flagteam = CTFFlag(Other.PlayerReplicationInfo.HasFlag).Team;
+		if (Other.PlayerReplicationInfo.Team != flagteam)
+			class'WFPlayerClassInfo'.static.SendEvent(Other, "flag_dropped");
+		else class'WFPlayerClassInfo'.static.SendEvent(Other, "flag_dropped_own");
+	}
 
 	if (DamageType == 'RefLogin')
 	{
@@ -199,6 +379,8 @@ function Killed( pawn Killer, pawn Other, name damageType )
 		return;
 	}
 
+	bPointGiven = false;
+
 	if ((Other != None) && Other.bIsPlayer)
 	{
 		pack = Other.spawn(class'WFBackPack',,, Other.Location);
@@ -215,17 +397,95 @@ function Killed( pawn Killer, pawn Other, name damageType )
 
 	// lazy hack to get around the +4 bonus for shooting down a flag carrier
 	if ( Other.bIsPlayer && (Other.PlayerReplicationInfo.HasFlag != None) )
-		if ( (Killer != None) && Killer.bIsPlayer && Other.bIsPlayer && (Killer.PlayerReplicationInfo.Team != Other.PlayerReplicationInfo.Team) )
+	{
+		if ( ( Killer != None ) &&
+           Killer.bIsPlayer &&
+           Other.bIsPlayer &&
+           ( Killer.PlayerReplicationInfo.Team !=
+             Other.PlayerReplicationInfo.Team ) )
 		{
 			killer.PlayerReplicationInfo.Score -= 4;
 			killer.PlayerReplicationInfo.Score += KilledFlagCarrierBonus;
+
+      //points for killing the flag runner
+
+      class'WFTools'.static.AdjustMiscScore(killer.PlayerReplicationInfo,
+                                            INDEX_FlagCarrierKills, 1);
+      WFTeamInfo( TournamentGameReplicationInfo(GameReplicationInfo) .Teams[  killer.PlayerReplicationInfo.Team ] ).MiscScoreArray[ INDEX_FlagCarrierKills ]++;
+			Killer.ReceiveLocalizedMessage( class'WFFlagRunnerKillMessage', 0, Other.PlayerReplicationInfo );
+		  bPointGiven = true;
 		}
+	}
+
+  // given points for flag runner defends
+	if (Killer != None)
+	{
+		for ( i=0; i<4; i++ )
+		{
+			Flag = WFFlag(CTFReplicationInfo(GameReplicationInfo).FlagList[i]);
+			if( Flag == None )
+			{
+			  continue;
+			}
+
+			//FlagLocation = Flag.Location;
+			FlagLocation = Flag.Position().Location;
+
+			bFlagLOS = ((Killer != None) && Killer.FastTrace(FlagLocation))
+						|| ((Other != None) && Other.FastTrace(FlagLocation));
+
+			if (!bFlagLOS)
+				continue;
+
+			if( !bPointGiven && ( Flag.Holder != None ) )
+			{
+					HolderPRI = Flag.Holder.PlayerReplicationInfo;
+				if ( ( HolderPRI.Team == Killer.PlayerReplicationInfo.Team ) &&
+				   ( Killer.PlayerReplicationInfo.Team != Other.PlayerReplicationInfo.Team ) &&
+						 ( Flag.bHeld ) &&
+							 ( Flag.Holder != Killer ) &&
+				   ( VSize( FlagLocation - Other.Location ) < DefendRadius ) )
+				{
+          class'WFTools'.static.AdjustMiscScore(killer.PlayerReplicationInfo,
+                                                INDEX_FlagCarrierDefends, 1);
+          WFTeamInfo( TournamentGameReplicationInfo(GameReplicationInfo) .Teams[ killer.PlayerReplicationInfo.Team ] ).MiscScoreArray[ INDEX_FlagCarrierDefends ]++;
+
+					bPointGiven = true;
+					Killer.ReceiveLocalizedMessage( class'WFFlagRunnerDefendMessage', 0, killer.PlayerReplicationInfo );
+					Flag.Holder.ReceiveLocalizedMessage( class'WFDefendedMessage', 0, killer.PlayerReplicationInfo, HolderPRI );
+					break;
+				}
+			}
+
+			if( !bPointGiven )
+			{
+				if ( ( Flag.Team == Killer.PlayerReplicationInfo.Team ) &&
+				   ( Other.PlayerReplicationInfo.Team != Killer.PlayerReplicationInfo.Team ) &&
+						 ( !Flag.bHeld ) &&
+							 ( !Flag.bReturning ) &&
+				   ( VSize( FlagLocation - Other.Location ) < DefendRadius ) )
+				{
+          class'WFTools'.static.AdjustMiscScore(killer.PlayerReplicationInfo, INDEX_FlagDefends, 1);
+          WFTeamInfo( TournamentGameReplicationInfo(GameReplicationInfo) .Teams[ killer.PlayerReplicationInfo.Team ] ).MiscScoreArray[ INDEX_FlagDefends ]++;
+			    bPointGiven = true;
+			 	  Killer.ReceiveLocalizedMessage( class'WFFlagDefendMessage', 0, killer.PlayerReplicationInfo );
+					break;
+				}
+			}
+		}
+	}
+
+  class'WFTools'.static.AdjustMiscScore(killer.PlayerReplicationInfo,
+                                            INDEX_Frags, 1);
+  WFTeamInfo( TournamentGameReplicationInfo(GameReplicationInfo) .Teams[ killer.PlayerReplicationInfo.Team ] ).MiscScoreArray[ INDEX_Frags ]++;
+
 
 	super.Killed(Killer, Other, damageType);
 }
 
 function ScoreKill(pawn Killer, pawn Other)
 {
+
 	if ((Killer != None) && (Other != None) && Killer.bIsPlayer && Other.IsA('WFAutoCannon'))
 	{
 		if (!IsOnTeam(Other, Killer.PlayerReplicationInfo.Team))
@@ -304,8 +564,28 @@ function CheckTeamSizes()
 
 function bool RestartPlayer( pawn aPlayer )
 {
+	local bool bResult;
+	local WFSpawnProtector SP;
 	EnableFlagTouch(aPlayer);
-	return super.RestartPlayer(aPlayer);
+
+	// hack to prevent CSHP from interfering with the initial player states
+	if ( (aPlayer.Physics == PHYS_Walking) && (aPlayer.IsInState('PCSpectating') || aPlayer.IsInState('RefereeMode')) )
+	{
+		aPlayer.SetPhysics(PHYS_None);
+		return false;
+	}
+
+	bResult = super.RestartPlayer(aPlayer);
+
+	if ((SpawnProtectionTime > 0.0) && (aPlayer.PlayerReplicationInfo.Team < MaxTeams)
+		&& !aPlayer.IsInState('PCSpectating'))
+	{
+		SP = spawn(class'WFSpawnProtector', aPlayer,, aPlayer.Location);
+		if (SP != None)
+			SP.GiveTo(aPlayer);
+	}
+
+	return bResult;
 }
 
 function EnableFlagTouch(pawn Other)
@@ -1082,21 +1362,47 @@ function bool FindPathToMarker(Bot aBot, WFMarker aMarker)
 	return (aBot.bNoClearSpecial || (aBot.MoveTarget != None));
 }
 
+function ScoreFlag(Pawn Scorer, CTFFlag theFlag)
+{
+  local WF_PRI WFPRI;
+  local WF_BotPRI WFBotPRI;
+  local int index;
+
+  index = INDEX_FlagCaps;
+  if( Scorer.PlayerReplicationInfo.Team == theFlag.Team )
+  {
+    index = INDEX_FlagReturns;
+  }
+  class'WFTools'.static.AdjustMiscScore(Scorer.PlayerReplicationInfo,
+                                        index, 1);
+  WFTeamInfo( TournamentGameReplicationInfo(GameReplicationInfo) .Teams[ Scorer.PlayerReplicationInfo.Team ] ).MiscScoreArray[ index ]++;
+
+  super.ScoreFlag( Scorer, theFlag );
+}
+
 defaultproperties
 {
      ClassDefinitions(0)="WFCode.WFPlayerClassList"
      ClassDefinitions(1)="WFCode.WFPlayerClassList"
      ClassDefinitions(2)="WFCode.WFPlayerClassList"
      ClassDefinitions(3)="WFCode.WFPlayerClassList"
-     WFGameVersion="106.1a"
+     WFGameVersion="107b"
      FRS_TouchReturn=1
      FRS_CarryReturn=2
      FlagReturnTime=40.000000
+     DefendRadius=2084.000000
+     FlagRunnerDefendRadius=2048.000000
      TeamPasswordDialogClass(0)=Class'WFCode.WFTeamPasswordDialogWDI_Red'
      TeamPasswordDialogClass(1)=Class'WFCode.WFTeamPasswordDialogWDI_Blue'
      TeamPasswordDialogClass(2)=Class'WFCode.WFTeamPasswordDialogWDI_Green'
      TeamPasswordDialogClass(3)=Class'WFCode.WFTeamPasswordDialogWDI_Gold'
+     SpawnProtectionTime=8.000000
      KilledFlagCarrierBonus=1
+     INDEX_FlagDefends=1
+     INDEX_FlagCarrierKills=2
+     INDEX_FlagCarrierDefends=3
+     INDEX_FlagReturns=4
+     INDEX_Frags=7
      PCPlayerClass=Class'WFCode.WFPlayer'
      PCBotClass=Class'WFCode.WFBot'
      DefaultMapInfo=Class'WFCode.WFGameMapSetupInfo'
@@ -1104,13 +1410,13 @@ defaultproperties
      DefaultTeamClassList(1)=Class'WFCode.WFPlayerClassList'
      DefaultTeamClassList(2)=Class'WFCode.WFPlayerClassList'
      DefaultTeamClassList(3)=Class'WFCode.WFPlayerClassList'
-     DefaultExtendedHUDClass=Class'WFCode.WFHUDInfo'
+     DefaultExtendedHUDClass=Class'WFCode.WFCustomHUDInfo'
      bVoiceMetaClassCheck=True
      FragLimit=0
-     ScoreBoardType=Class'WFCode.WFScoreBoard'
+     ScoreBoardType=Class'WFCode.WFCustomScoreboard'
      RulesMenuType="WFCode.WFRSClient"
      SettingsMenuType="WFCode.WFSSClient"
-     HUDType=Class'WFCode.WFHUD'
+     HUDType=Class'WFCode.WFCustomHUD'
      MapListType=Class'WFCode.WFGameMapList'
      BeaconName="WF"
      GameName="Weapons Factory"
diff --git a/WFCode/Classes/WFGameGRI.uc b/WFCode/Classes/WFGameGRI.uc
index db51305..66cff1e 100644
--- a/WFCode/Classes/WFGameGRI.uc
+++ b/WFCode/Classes/WFGameGRI.uc
@@ -3,6 +3,14 @@
 //=============================================================================
 class WFGameGRI extends WFS_PCSystemGRI;
 
+var byte FlagReturnStyle;
+
+replication
+{
+	reliable if (Role == ROLE_Authority)
+		FlagReturnStyle;
+}
+
 defaultproperties
 {
 }
diff --git a/WFCode/Classes/WFGasStreamGen.uc b/WFCode/Classes/WFGasStreamGen.uc
index 5c3a354..75319dd 100644
--- a/WFCode/Classes/WFGasStreamGen.uc
+++ b/WFCode/Classes/WFGasStreamGen.uc
@@ -3,6 +3,7 @@ class WFGasStreamGen extends WFFlameThrowerFlameGen;
 defaultproperties
 {
      FlameClass=Class'WFCode.WFGasStreamPuff'
+     AltFlameClass=Class'WFCode.WFGasStreamPuffAlt'
      FlameRate=0.110000
      AmbientSound=Sound'UnrealShare.ASMD.Vapour'
 }
diff --git a/WFCode/Classes/WFGasStreamPuff.uc b/WFCode/Classes/WFGasStreamPuff.uc
index 229e763..bc50743 100644
--- a/WFCode/Classes/WFGasStreamPuff.uc
+++ b/WFCode/Classes/WFGasStreamPuff.uc
@@ -19,6 +19,7 @@ function CauseDamage(pawn Other, vector HitLocation)
 	local class<WFPlayerClassInfo> PCI;
 	local WFStatusInfected s;
 	local bool bGiveStatus;
+	local WFPlayer WFP;
 
 	if ((Level.NetMode == NM_Client) || (Other == None))
 		return;
@@ -28,8 +29,10 @@ function CauseDamage(pawn Other, vector HitLocation)
 		Other.TakeDamage(1*byte(FRand()<0.2), Instigator, HitLocation, vect(0,0,0), 'Gassed');
 		if (Other.Health > 0)
 		{
-			PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
-			bGiveStatus = ((PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusInfected'))
+			//WFP = WFPlayer(Other);
+			//PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
+			//bGiveStatus = ((PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusInfected'))
+			bGiveStatus = (!class'WFPlayerClassInfo'.static.PawnIsImmuneTo(Other, class'WFStatusInfected'))
 				&& (Other.FindInventoryType(class'WFStatusVaccinated') == None);
 			bGiveStatus = bGiveStatus && (Other.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team);
 			if (bGiveStatus && (FRand() <= InfectOdds))
diff --git a/WFCode/Classes/WFGrenConc.uc b/WFCode/Classes/WFGrenConc.uc
index b9adc0e..dedac2d 100644
--- a/WFCode/Classes/WFGrenConc.uc
+++ b/WFCode/Classes/WFGrenConc.uc
@@ -13,6 +13,7 @@ defaultproperties
      PickupMessage="You picked up a Concussion Grenade"
      ItemName="Concussion Grenade"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadeConc'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      Icon=Texture'UnrealI.Icons.I_SludgeAmmo'
      CollisionRadius=18.000000
diff --git a/WFCode/Classes/WFGrenDecloaker.uc b/WFCode/Classes/WFGrenDecloaker.uc
index 53aaa87..627a796 100644
--- a/WFCode/Classes/WFGrenDecloaker.uc
+++ b/WFCode/Classes/WFGrenDecloaker.uc
@@ -35,7 +35,9 @@ defaultproperties
      ProjectileClass=Class'WFCode.WFGrenDecloakerProj'
      GrenadeSlot=2
      PrimingTime=0.500000
+     ItemName="Decloaker"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadeDecloaker'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      CollisionRadius=18.000000
      CollisionHeight=8.000000
diff --git a/WFCode/Classes/WFGrenDecloakerField.uc b/WFCode/Classes/WFGrenDecloakerField.uc
index fa2c7bc..b9a23fd 100644
--- a/WFCode/Classes/WFGrenDecloakerField.uc
+++ b/WFCode/Classes/WFGrenDecloakerField.uc
@@ -57,9 +57,10 @@ function Decloak(pawn Other)
 			Inv.Charge = 0;
 		else if (Inv.IsA('WFCloaker') && Inv.bActive)
 		{
-			WFCloaker(Inv).ActivateDelay = 0;
-			Inv.Activate();
-			WFCloaker(Inv).ActivateDelay = 5;
+			Inv.Charge = 0;
+			//WFCloaker(Inv).ActivateDelay = 0;
+			//Inv.Activate();
+			//WFCloaker(Inv).ActivateDelay = 5;
 		}
 	}
 }
@@ -102,6 +103,10 @@ function Touch( actor Other )
 function Tick(float DeltaTime)
 {
 	local actor a;
+
+	if ((Owner != None) && (Location != Owner.Location))
+		SetLocation(Owner.Location);
+
 	if ((Level.TimeSeconds - LastEffectTime) >= NextEffectTime)
 	{
 		a = spawn(class'WFGrenDecloakerFieldEffect',,, Location + 8*vect(0,0,1));
diff --git a/WFCode/Classes/WFGrenEMP.uc b/WFCode/Classes/WFGrenEMP.uc
index 620c385..2332633 100644
--- a/WFCode/Classes/WFGrenEMP.uc
+++ b/WFCode/Classes/WFGrenEMP.uc
@@ -9,6 +9,7 @@ defaultproperties
      PickupMessage="You picked up an EMP Grenade"
      ItemName="EMP Grenade"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadeEMP'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      Icon=Texture'UnrealI.Icons.I_SludgeAmmo'
      CollisionRadius=18.000000
diff --git a/WFCode/Classes/WFGrenFlame.uc b/WFCode/Classes/WFGrenFlame.uc
index 1ef6279..e207e76 100644
--- a/WFCode/Classes/WFGrenFlame.uc
+++ b/WFCode/Classes/WFGrenFlame.uc
@@ -10,6 +10,7 @@ defaultproperties
      PickupMessage="You picked up a Flame Grenade"
      ItemName="Flame Grenade"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadeFlame'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      Icon=Texture'UnrealI.Icons.I_SludgeAmmo'
      CollisionRadius=18.000000
diff --git a/WFCode/Classes/WFGrenFlameSpark.uc b/WFCode/Classes/WFGrenFlameSpark.uc
index d0c6eb3..20e8244 100644
--- a/WFCode/Classes/WFGrenFlameSpark.uc
+++ b/WFCode/Classes/WFGrenFlameSpark.uc
@@ -33,6 +33,7 @@ function BlowUp(vector HitLocation)
 	local WFStatusOnFire s;
 	local bool bGiveStatus;
 	local class<WFPlayerClassInfo> PCI;
+	local WFPlayer WFP;
 
 	if( bHurtEntry )
 		return;
@@ -63,8 +64,10 @@ function BlowUp(vector HitLocation)
 				aPawn = pawn(Victims);
 				if (aPawn.bIsPlayer && (aPawn.Health > 0))
 				{
-					PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
-					bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+					//WFP = WFPlayer(aPawn);
+					//PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
+					//bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+					bGiveStatus = !class'WFPlayerClassInfo'.static.PawnIsImmuneTo(aPawn, class'WFStatusOnFire');
 
 					if (bGiveStatus && (aPawn.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team))
 					{
diff --git a/WFCode/Classes/WFGrenFlash.uc b/WFCode/Classes/WFGrenFlash.uc
index dcae04a..26a8063 100644
--- a/WFCode/Classes/WFGrenFlash.uc
+++ b/WFCode/Classes/WFGrenFlash.uc
@@ -13,6 +13,7 @@ defaultproperties
      PickupMessage="You picked up a Flash Grenade"
      ItemName="Flash Grenade"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadeFlash'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      Icon=Texture'UnrealI.Icons.I_SludgeAmmo'
      CollisionRadius=18.000000
diff --git a/WFCode/Classes/WFGrenFrag.uc b/WFCode/Classes/WFGrenFrag.uc
index b535ed1..c4f76b5 100644
--- a/WFCode/Classes/WFGrenFrag.uc
+++ b/WFCode/Classes/WFGrenFrag.uc
@@ -10,6 +10,7 @@ defaultproperties
      PickupMessage="You picked up a Frag Grenade"
      ItemName="Frag Grenade"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadeFrag'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      Icon=Texture'UnrealI.Icons.I_SludgeAmmo'
      CollisionRadius=18.000000
diff --git a/WFCode/Classes/WFGrenFreeze.uc b/WFCode/Classes/WFGrenFreeze.uc
index 890cd65..de878d8 100644
--- a/WFCode/Classes/WFGrenFreeze.uc
+++ b/WFCode/Classes/WFGrenFreeze.uc
@@ -41,6 +41,7 @@ defaultproperties
      PickupMessage="You picked up a Freeze Grenade"
      ItemName="Freeze Grenade"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadeFreeze'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      Icon=Texture'UnrealI.Icons.I_SludgeAmmo'
      CollisionRadius=18.000000
diff --git a/WFCode/Classes/WFGrenFreezeCloud.uc b/WFCode/Classes/WFGrenFreezeCloud.uc
index 6b6d215..b94cce2 100644
--- a/WFCode/Classes/WFGrenFreezeCloud.uc
+++ b/WFCode/Classes/WFGrenFreezeCloud.uc
@@ -20,6 +20,7 @@ function FreezePlayer(pawn Other, vector HitLocation)
 	local bool bGiveStatus, bSameTeam;
 	local WFPlayerStatus s;
 	local class<WFPlayerClassInfo> PCI;
+	local WFPlayer WFP;
 
 	if ((Other != Instigator) && Other.bIsPlayer)
 	{
@@ -27,8 +28,11 @@ function FreezePlayer(pawn Other, vector HitLocation)
 		{
 			if ((Other.Health > 0) && ((Instigator == None) || (Other.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team)))
 			{
-				PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
-				bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusFrozen');
+				//WFP = WFPlayer(Other);
+				//PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
+				//bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusFrozen');
+				bGiveStatus = !class'WFPlayerClassInfo'.static.PawnIsImmuneTo(Other, class'WFStatusFrozen');
+
 				if (bGiveStatus)
 				{
 					s = spawn(class'WFStatusFrozen',,, Other.Location);
diff --git a/WFCode/Classes/WFGrenPlague.uc b/WFCode/Classes/WFGrenPlague.uc
index dccca37..431801a 100644
--- a/WFCode/Classes/WFGrenPlague.uc
+++ b/WFCode/Classes/WFGrenPlague.uc
@@ -9,6 +9,7 @@ defaultproperties
      PickupMessage="You picked up a Plague Grenade"
      ItemName="Plague Grenade"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadePlague'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      Icon=Texture'UnrealI.Icons.I_SludgeAmmo'
      CollisionRadius=18.000000
diff --git a/WFCode/Classes/WFGrenPlagueGasPuff.uc b/WFCode/Classes/WFGrenPlagueGasPuff.uc
index d15523f..782f3ec 100644
--- a/WFCode/Classes/WFGrenPlagueGasPuff.uc
+++ b/WFCode/Classes/WFGrenPlagueGasPuff.uc
@@ -21,6 +21,7 @@ function CauseDamage(pawn Other, vector HitLocation)
 	local class<WFPlayerClassInfo> PCI;
 	local WFStatusInfected s;
 	local bool bGiveStatus;
+	local WFPlayer WFP;
 
 	if ((Other == None) || (Role != ROLE_Authority))
 		return;
@@ -30,8 +31,10 @@ function CauseDamage(pawn Other, vector HitLocation)
 		Other.TakeDamage(Damage, Instigator, HitLocation, vect(0,0,0), 'PlagueGrenade');
 		if (Other.Health > 0)
 		{
-			PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
-			bGiveStatus = ((PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusInfected'))
+			//WFP = WFPlayer(Other);
+			//PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
+			//bGiveStatus = ((PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusInfected'))
+			bGiveStatus = !class'WFPlayerClassInfo'.static.PawnIsImmuneTo(Other, class'WFStatusInfected')
 				&& (Other.FindInventoryType(class'WFStatusVaccinated') == None);
 			bGiveStatus = bGiveStatus && (Other.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team);
 			if (bGiveStatus && (FRand() <= InfectOdds))
@@ -69,7 +72,7 @@ defaultproperties
      InfectOdds=0.250000
      speed=50.000000
      MaxSpeed=75.000000
-     Damage=5.000000
+     Damage=1.000000
      SpawnSound=Sound'UnrealShare.ASMD.Vapour'
      RemoteRole=ROLE_SimulatedProxy
      LifeSpan=5.000000
diff --git a/WFCode/Classes/WFGrenShock.uc b/WFCode/Classes/WFGrenShock.uc
index fb9b9a9..08bb916 100644
--- a/WFCode/Classes/WFGrenShock.uc
+++ b/WFCode/Classes/WFGrenShock.uc
@@ -10,6 +10,7 @@ defaultproperties
      PickupMessage="You picked up a Shock Grenade"
      ItemName="Shock Grenade"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadeShock'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      Icon=Texture'UnrealI.Icons.I_SludgeAmmo'
      CollisionRadius=18.000000
diff --git a/WFCode/Classes/WFGrenShockBoltParent.uc b/WFCode/Classes/WFGrenShockBoltParent.uc
index f2e8e40..9a277b0 100644
--- a/WFCode/Classes/WFGrenShockBoltParent.uc
+++ b/WFCode/Classes/WFGrenShockBoltParent.uc
@@ -5,9 +5,12 @@ function bool ValidTarget(actor Other)
 	if (!super.ValidTarget(Other))
 		return false;
 
-	// don't target anything on same team as instigator
+	// don't target anything on same team as instigator, or cloaked/disguised infiltrators
 	if (Other.bIsPawn && (Instigator != None) && Level.Game.IsA('TeamGamePlus')
-		&& TeamGamePlus(Level.Game).IsOnTeam(pawn(Other), Instigator.PlayerReplicationInfo.Team))
+		&& ( ( !class'WFCloaker'.static.IsHalfCloaked(Pawn(other))
+				&& ( class'WFCloaker'.static.IsCloaked(Pawn(other)))
+					|| class'WFDisguise'.static.IsDisguised(pawn(Other).PlayerReplicationInfo)) )
+			|| TeamGamePlus(Level.Game).IsOnTeam(pawn(Other), Instigator.PlayerReplicationInfo.Team) )
 		return false;
 
 	return true;
diff --git a/WFCode/Classes/WFGrenTurret.uc b/WFCode/Classes/WFGrenTurret.uc
index ab6399b..85b644a 100644
--- a/WFCode/Classes/WFGrenTurret.uc
+++ b/WFCode/Classes/WFGrenTurret.uc
@@ -39,6 +39,7 @@ defaultproperties
      PickupMessage="You picked up a Turret Grenade"
      ItemName="Turret Grenade"
      PickupViewMesh=LodMesh'UnrealShare.VoiceBoxMesh'
+     StatusIcon=Texture'WFMedia.GrenadeTurret'
      PickupSound=Sound'UnrealShare.Pickups.GenPickSnd'
      Icon=Texture'UnrealI.Icons.I_SludgeAmmo'
      CollisionRadius=18.000000
diff --git a/WFCode/Classes/WFGrenTurretProj.uc b/WFCode/Classes/WFGrenTurretProj.uc
index af13daf..4a2c13b 100644
--- a/WFCode/Classes/WFGrenTurretProj.uc
+++ b/WFCode/Classes/WFGrenTurretProj.uc
@@ -232,10 +232,7 @@ function pawn FindTarget()
 
 	foreach VisibleCollidingActors(class'pawn', p, Range)
 	{
-		if ( p.bIsPlayer && (p.Health > 0) && FastTrace(p.Location, Location)
-			&& (p.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team)
-			&& (!class'WFDisguise'.static.IsDisguised(P.PlayerReplicationInfo)
-				|| (GetDisguiseTeam(p) != Instigator.PlayerReplicationInfo.Team)) )
+		if ( ValidTarget(p) )
 		{
 			dist = VSize(p.Location - Location);
 			if (dist < bestdist)
@@ -249,6 +246,17 @@ function pawn FindTarget()
 	return best;
 }
 
+function bool ValidTarget(pawn Other)
+{
+	if ( (Other != None) && Other.bIsPlayer && (Other.Health > 0) && FastTrace(Other.Location, Location)
+		&& (Other.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team)
+		&& (class'WFCloaker'.static.IsHalfCloaked(Other) || (!class'WFDisguise'.static.IsDisguised(Other.PlayerReplicationInfo))
+			&& !class'WFCloaker'.static.IsCloaked(Other)) )
+		return true;
+
+	return false;
+}
+
 function byte GetDisguiseTeam(pawn Other)
 {
 	local WFDisguise Disguise;
@@ -274,11 +282,7 @@ function ShootAt(actor Other)
 	ActualDir = Normal(Other.Location - Location);
 	Dir = vector(GetShootRot());
 
-	if ( (VSize(Other.Location - Location) > Range)
-		|| (Other.bIsPawn && ( (PawnOther.Health <= 0))
-			|| (class'WFDisguise'.static.IsDisguised(PawnOther.PlayerReplicationInfo)
-				&& (GetDisguiseTeam(PawnOther) == Instigator.PlayerReplicationInfo.Team)) )
-		|| !FastTrace(Other.Location, Location))
+	if ( !ValidTarget(pawn(Other)) || (VSize(Other.Location - Location) > Range) )
 	{
 		Target = FindTarget();
 		if (Target == None)
diff --git a/WFCode/Classes/WFGrenadeItem.uc b/WFCode/Classes/WFGrenadeItem.uc
index bc5bf19..09879bf 100644
--- a/WFCode/Classes/WFGrenadeItem.uc
+++ b/WFCode/Classes/WFGrenadeItem.uc
@@ -26,20 +26,13 @@ function actor ThrowGrenade()
 	VelocityScale = Max(1.0, ThrowingTime);
 	InitialVelocity = (FMin(BaseVelocity * VelocityScale, MaximumVelocity) * Normal(dir)) + Owner.Velocity*0.5;
 
-	// remove any disguise and cloak the player has
-	// TODO: hrm, convert this to an inventory notification rather than hard code it here
-	if (class'WFDisguise'.static.IsDisguised(pawn(Owner).PlayerReplicationInfo))
+	// notify any WFPickups that a grenade was thrown
+	for (Item=pawn(Owner).Inventory; Item!=None; Item=Item.Inventory)
 	{
-		for (Item=pawn(Owner).Inventory; Item!=None; Item=Item.Inventory)
-		{
-			if ((Item != None) && Item.IsA('WFDisguise'))
-				WFDisguise(Item).RemoveDisguise();
-			if ((Item != None) && Item.IsA('WFCloaker') && Item.IsInState('Active'))
-			{
-				WFCloaker(Item).ActivateDelay = 0;
-				WFCloaker(Item).Activate();
-			}
-		}
+		if ((Item != None) && Item.IsA('WFPickup'))
+			WFPickup(Item).GrenadeThrown(self);
+		//if ((Item != None) && Item.IsA('WFCloaker') && Item.IsInState('Active'))
+		//	WFCloaker(Item).GrenadeThrown(self);
 	}
 
 	return DropProjectile(InitialVelocity);
diff --git a/WFCode/Classes/WFGrenadeLauncher.uc b/WFCode/Classes/WFGrenadeLauncher.uc
index b8f33b8..365fa65 100644
--- a/WFCode/Classes/WFGrenadeLauncher.uc
+++ b/WFCode/Classes/WFGrenadeLauncher.uc
@@ -174,7 +174,7 @@ defaultproperties
      PickupViewMesh=LodMesh'WFMedia.grenpick'
      ThirdPersonMesh=LodMesh'WFMedia.grenthird'
      ThirdPersonScale=0.750000
-     StatusIcon=Texture'Botpack.Icons.Use8ball'
+     StatusIcon=Texture'WFMedia.WeaponGrenadeLauncher'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.Use8ball'
      Mesh=LodMesh'WFMedia.grenpick'
diff --git a/WFCode/Classes/WFGunner.uc b/WFCode/Classes/WFGunner.uc
index 59646ed..dbdc51b 100644
--- a/WFCode/Classes/WFGunner.uc
+++ b/WFCode/Classes/WFGunner.uc
@@ -7,12 +7,12 @@ var int MaxTripmines;
 
 static function ModifyPlayer(pawn Other)
 {
-	Other.GroundSpeed = Other.default.GroundSpeed * 0.75;
-	Other.WaterSpeed = Other.default.WaterSpeed * 0.75;
-	Other.AirSpeed = Other.default.AirSpeed * 0.75;
-	Other.AccelRate = Other.default.AccelRate * 0.75;
-	Other.AirControl = Other.default.AirControl * 0.75;
-	Other.Mass = Other.default.Mass * 1.25;
+	Other.GroundSpeed = Other.default.GroundSpeed * 0.85;
+	Other.WaterSpeed = Other.default.WaterSpeed * 0.85;
+	Other.AirSpeed = Other.default.AirSpeed * 0.85;
+	Other.AccelRate = Other.default.AccelRate * 0.85;
+	Other.AirControl = Other.default.AirControl * 0.85;
+	Other.Mass = Other.default.Mass * 1.15;
 }
 
 static function bool IsClientSideCommand(string SpecialString)
@@ -37,11 +37,11 @@ static function DoSpecial(pawn Other, string SpecialString, optional name Type)
 		SetTripmine(Other);
 	else if (SpecialString ~= "RemoveMine")
 		RemoveTripmine(Other);
-	else if (SpecialString ~= "RemoveDecloaker")
+	/*else if (SpecialString ~= "RemoveDecloaker")
 	{
 		if (!RemoveDecloakers(Other))
 			Other.ClientMessage("No Decloakers to remove");
-	}
+	}*/
 }
 
 
@@ -168,7 +168,7 @@ static function DestroyAllRelatedActors(pawn Other)
 defaultproperties
 {
      MaxTripmines=1
-     TranslocatorAmmoUsed=35
+     TranslocatorAmmoUsed=25
      bNoEnforcer=True
      ClassName="Gunner"
      ClassNamePlural="Gunners"
diff --git a/WFCode/Classes/WFGunnerHUDMenu.uc b/WFCode/Classes/WFGunnerHUDMenu.uc
index 8986817..07e2ddf 100644
--- a/WFCode/Classes/WFGunnerHUDMenu.uc
+++ b/WFCode/Classes/WFGunnerHUDMenu.uc
@@ -20,10 +20,10 @@ function ProcessSelection(int Selection)
 			PlayerOwner.Special("DeployAlarm");
 			CloseMenu();
 			break;
-		case 8:
+		/*case 8:
 			PlayerOwner.Special("RemoveDecloaker");
 			CloseMenu();
-			break;
+			break;*/
 		case 10:
 			CloseMenu();
 			break;
@@ -37,13 +37,11 @@ defaultproperties
      MenuOptions(2)=" "
      MenuOptions(3)="Deploy Alarm"
      MenuOptions(4)=" "
-     MenuOptions(7)="Remove Decloaker Mine"
-     MenuOptions(8)=" "
      MenuOptions(9)="Close Menu"
      MenuTitle="[ - Gunner Options - ]"
      SeparatorString=":  "
      bAlignAppendString=True
      bUseColors=True
-     NumOptions=8
+     NumOptions=4
      DisplayTime=10
 }
diff --git a/WFCode/Classes/WFHUD.uc b/WFCode/Classes/WFHUD.uc
index 550569e..51275b8 100644
--- a/WFCode/Classes/WFHUD.uc
+++ b/WFCode/Classes/WFHUD.uc
@@ -6,9 +6,7 @@
 class WFHUD extends WFS_PCSystemHUD;
 
 // local references to rendered status (ensures reliable rendering)
-var WFPlayerStatus RenderList[16], Exclusive, RenderChain;
 var string TeamColorStr[4];
-var int StatusCount;
 
 var localized string IdentifyArmor;
 
@@ -23,81 +21,12 @@ var float HintSlideTime; // time taken for hints to slide on-screen
 
 var config bool bShowConsoleHints;
 
-simulated function PostRender(canvas Canvas)
+var float lastdebuglog;
+
+simulated function DebugLog(coerce string S, float MinDelay)
 {
-	RenderPlayerStatus(Canvas);
-	super.PostRender(Canvas);
-}
-
-simulated function RenderPlayerStatus(canvas Canvas)
-{
-	local int i;
-
-	if (PawnOwner == None)
-		return;
-
-	if ((Exclusive != None) && Exclusive.bExclusiveRender)
-	{
-		if (Exclusive.bDeleteMe)
-			Exclusive = None;
-		else
-		{
-			Exclusive.RenderStatus(Canvas);
-			return;
-		}
-	}
-
-	if (RenderChain != None)
-		RenderChain.RenderStatusChain(Canvas);
-}
-
-simulated function AddRenderedStatus(WFPlayerStatus NewStatus)
-{
-	local int i;
-
-	if (NewStatus.bExclusiveRender)
-	{
-		if ((Exclusive == None) || (Exclusive.bDeleteMe)
-			|| (Exclusive.RenderPriority < NewStatus.RenderPriority))
-		{
-			Exclusive = NewStatus;
-			return;
-		}
-	}
-
-	// add to the render list
-	if (RenderChain == None)
-	{
-		NewStatus.bRegistered = true;
-		RenderChain = NewStatus;
-	}
-	else if (RenderChain.RenderPriority > NewStatus.RenderPriority)
-	{
-		NewStatus.bRegistered = true;
-		NewStatus.NextStatus = RenderChain;
-		RenderChain = NewStatus;
-	}
-	else RenderChain.AddStatus(NewStatus);
-}
-
-simulated function RemoveRenderedStatus(WFPlayerStatus OldStatus)
-{
-	local WFPlayerStatus S;
-
-	if (Exclusive == OldStatus)
-	{
-		Exclusive = None;
-		OldStatus.bRegistered = false;
-	}
-
-	for (S=RenderChain; S!=None; S=S.NextStatus)
-	{
-		if (S.NextStatus == OldStatus)
-		{
-			S.NextStatus = OldStatus.NextStatus;
-			OldStatus.bRegistered = false;
-		}
-	}
+	if ((Level.TimeSeconds - lastdebuglog) > MinDelay)
+		Log(S);
 }
 
 // Uses WFTeamSayMessagePlus message class to fix a spacing bug with team messages.
@@ -178,6 +107,7 @@ simulated function bool TraceIdentify(canvas Canvas)
 	local actor Other;
 	local vector HitLocation, HitNormal, StartTrace, EndTrace;
 	local class<WFPlayerClassInfo> PCI;
+	local string IDName;
 
 	StartTrace = PawnOwner.Location;
 	StartTrace.Z += PawnOwner.BaseEyeHeight;
@@ -187,7 +117,8 @@ simulated function bool TraceIdentify(canvas Canvas)
 	if ( Pawn(Other) != None )
 	{
 		PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(pawn(Other)));
-		if ( Pawn(Other).bIsPlayer && !Other.bHidden && ((PCI == None) || (PCI.default.bCanIdentify)) )
+		if ( Pawn(Other).bIsPlayer && !Other.bHidden && ((PCI == None) || (PCI.default.bCanIdentify))
+			&& !IsCloaked(pawn(Other)))
 		{
 			IdentifyTarget = Pawn(Other).PlayerReplicationInfo;
 			IdentifyFadeTime = 3.0;
@@ -202,6 +133,11 @@ simulated function bool TraceIdentify(canvas Canvas)
 	return true;
 }
 
+simulated function bool IsCloaked(pawn Other)
+{
+	return (Other != None) && (Other.Texture == FireTexture'Unrealshare.Belt_fx.Invis') && (Other.Style == STY_Translucent);
+}
+
 simulated function bool DrawIdentifyInfo(canvas Canvas)
 {
 	local float XL, YL, XOffset, X1;
@@ -209,6 +145,9 @@ simulated function bool DrawIdentifyInfo(canvas Canvas)
 	local byte bDisableFunction;
 	local bool Result;
 	local class<WFPlayerClassInfo> PCI;
+	local string IDName;
+	local bool bTargetDisguised;
+	local int pHealth;
 
 	if (ExtendedHUD != none)
 	{
@@ -217,25 +156,138 @@ simulated function bool DrawIdentifyInfo(canvas Canvas)
 			return Result;
 	}
 
-	if ( !Super(ChallengeHUD).DrawIdentifyInfo(Canvas) )
+	//if ( !Super(ChallengeHUD).DrawIdentifyInfo(Canvas) )
+	//	return false;
+
+	if ( !TraceIdentify(Canvas))
 		return false;
 
+	bTargetDisguised = class'WFDisguise'.static.IsDisguised(IdentifyTarget);
+	if( IdentifyTarget.PlayerName != "" )
+	{
+		Canvas.Font = MyFonts.GetBigFont(Canvas.ClipX);
+		IDName = IdentifyTarget.PlayerName;
+		if (bTargetDisguised && (IdentifyTarget.Team != PawnOwner.PlayerReplicationInfo.Team))
+			IDName = GetDisguisedNameFor(IdentifyTarget);
+		DrawTwoColorID(Canvas,IdentifyName, IDName, Canvas.ClipY - 256 * Scale);
+	}
+
 	PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(PlayerOwner));
 	Canvas.StrLen("TEST", XL, YL);
-	if( PawnOwner.PlayerReplicationInfo.Team == IdentifyTarget.Team )
+	if( bTargetDisguised || (PawnOwner.PlayerReplicationInfo.Team == IdentifyTarget.Team) )
 	{
 		P = Pawn(IdentifyTarget.Owner);
 		Canvas.Font = MyFonts.GetSmallFont(Canvas.ClipX);
 		if ( P != None )
 		{
+			pHealth = P.Health;
+			if (bTargetDisguised && (PCI != None))
+				pHealth = PCI.default.Health;
 			if ((PCI != None) && PCI.default.bDisplayArmorID)
 				DrawIDStatus(Canvas, p, (Canvas.ClipY - 256 * Scale) + 1.5 * YL);
-			else DrawTwoColorID(Canvas,IdentifyHealth,string(P.Health), (Canvas.ClipY - 256 * Scale) + 1.5 * YL);
+			else DrawTwoColorID(Canvas,IdentifyHealth,string(pHealth), (Canvas.ClipY - 256 * Scale) + 1.5 * YL);
 		}
 	}
 	return true;
 }
 
+// TODO - fix for more than 2 teams
+
+simulated function string GetClassName(PlayerReplicationInfo Other)
+{
+	local WF_PRI WFPRI;
+	local WF_BotPRI WFBotPRI;
+
+	WFPRI = WF_PRI(Other);
+	if (WFPRI != None)
+		return WFPRI.ClassName;
+	else
+	{
+		WFBotPRI = WF_BotPRI(Other);
+		if (WFBotPRI != None)
+			return WFBotPRI.ClassName;
+	}
+
+	return "";
+}
+
+simulated function string GetDisguisedNameFor(PlayerReplicationInfo PRI)
+{
+	local string ClassName, AltName;
+	local class<WFS_PlayerClassInfo> PCI;
+	local int i, j, index;
+	local WFGameGRI GRI;
+
+	if (PRI == None)
+		return "";
+
+	GRI = WFGameGRI(PlayerOwner.GameReplicationInfo);
+	if (GRI == None)
+		return "";
+
+	ClassName = GetClassName(PRI);
+	for (i=0; i<GRI.MaxTeams; i++)
+	{
+		if ((i != PRI.Team) && (GRI.TeamClassList[i] != None))
+		{
+			PCI = GRI.TeamClassList[i].GetClassByClassName(ClassName);
+			if (PCI != None)
+			{
+				index = GRI.TeamClassList[i].GetIndexOfClass(PCI);
+				if ((index != -1) && (GRI.TeamClassList[i].PlayerCounts[index] > 0))
+				{
+					// found maching class, get the first name associated with the class name
+					for (j=0; j<32; j++)
+					{
+						if ( (GRI.PRIArray[j] != None) && (GRI.PRIArray[j] != PRI)
+							&& (GRI.PRIArray[j].Team != PRI.Team)
+							&& (GRI.PRIArray[j] != PlayerOwner.PlayerReplicationInfo) )
+						{
+							if (AltName == "") // save first own teams player name as backup
+								AltName = GRI.PRIArray[j].PlayerName;
+							if ( !class'WFDisguise'.static.IsDisguised(GRI.PRIArray[j])
+								&& (GetClassName(GRI.PRIArray[j]) ~= ClassName) )
+								return GRI.PRIArray[j].PlayerName;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	// couldn't find player matching class
+	if (AltName == "") // no other names found
+		AltName = PRI.PlayerName;
+	return AltName;
+}
+
+simulated function class<WFS_PlayerClassInfo> GetDisguisedPCI(playerreplicationinfo PRI)
+{
+	local int i;
+	local WFGameGRI GRI;
+	local string ClassName;
+	local class<WFS_PlayerClassInfo> PCI;
+
+	if (PRI == None)
+		return None;
+
+	GRI = WFGameGRI(PlayerOwner.GameReplicationInfo);
+	if (GRI == None)
+		return None;
+
+	ClassName = GetClassName(PRI);
+	for (i=0; i<GRI.MaxTeams; i++)
+	{
+		if ((GRI.TeamClassList[i] != None))
+		{
+			PCI = GRI.TeamClassList[i].GetClassByClassName(ClassName);
+			if (PCI != None) return PCI;
+		}
+	}
+
+	return None;
+}
+
 // draw health and armor
 simulated function DrawIDStatus(canvas Canvas, pawn Other, int YStart)
 {
@@ -243,12 +295,28 @@ simulated function DrawIDStatus(canvas Canvas, pawn Other, int YStart)
 	local string Value1, Value2;
 	local class<WFS_PlayerClassInfo> PCI;
 	local int Armor, MaxArmor;
+	local bool bTargetDisguised;
 
 	Value1 = string(Other.Health);
 	Armor = GetArmorValue(Other);
 	Value2 = string(Armor);
 
-	PCI = class'WFS_PlayerClassInfo'.static.GetPCIFor(Other);
+	bTargetDisguised = class'WFDisguise'.static.IsDisguised(IdentifyTarget);
+
+	if (bTargetDisguised && (IdentifyTarget.Team != PawnOwner.PlayerReplicationInfo.Team))
+	{
+		PCI = GetDisguisedPCI(IdentifyTarget);
+		if (PCI != None)
+		{
+			Armor = PCI.default.Armor;
+			if (PCI.default.MaxArmor > 0)
+				Armor = PCI.default.Armor;
+			Value1 = string(PCI.default.Health);
+			Value2 = string(Armor);
+		}
+	}
+	else PCI = class'WFS_PlayerClassInfo'.static.GetPCIFor(Other);
+
 	if (PCI != None)
 	{
 		if (PCI.default.Armor > 0)
@@ -452,6 +520,29 @@ function float GetLongestStringWidth(canvas Canvas, optional bool bIncludeTitle)
 	return best;
 }
 
+simulated function SetIDColor( Canvas Canvas, int type )
+{
+	local byte Team;
+
+	if (class'WFDisguise'.static.IsDisguised(IdentifyTarget))
+		Team = PawnOwner.PlayerReplicationInfo.Team;
+	else Team = IdentifyTarget.Team;
+
+	if (Team > 3)
+	{
+		if (type == 0)
+			Canvas.DrawColor = WhiteColor * 0.5 * 0.333 * IdentifyFadeTime;
+		else
+			Canvas.DrawColor = WhiteColor * 0.333 * IdentifyFadeTime;
+		return;
+	}
+
+	if ( type == 0 )
+		Canvas.DrawColor = AltTeamColor[Team] * 0.333 * IdentifyFadeTime;
+	else
+		Canvas.DrawColor = TeamColor[Team] * 0.333 * IdentifyFadeTime;
+}
+
 exec function ShowHints()
 {
 	bShowConsoleHints = !bShowConsoleHints;
diff --git a/WFCode/Classes/WFHealingDepot.uc b/WFCode/Classes/WFHealingDepot.uc
index 50601bb..1bd738a 100644
--- a/WFCode/Classes/WFHealingDepot.uc
+++ b/WFCode/Classes/WFHealingDepot.uc
@@ -36,7 +36,7 @@ function PostBeginPlay()
 
 simulated function Tick(float DeltaTime)
 {
-	if (MyEffect != None)
+	if ((MyEffect != None) && (MyEffect.Location != Location + EffectOffset))
 		MyEffect.SetLocation(Location + EffectOffset);
 }
 
diff --git a/WFCode/Classes/WFHyperblaster.uc b/WFCode/Classes/WFHyperblaster.uc
index 195cc9d..f6b866f 100644
--- a/WFCode/Classes/WFHyperblaster.uc
+++ b/WFCode/Classes/WFHyperblaster.uc
@@ -325,9 +325,8 @@ defaultproperties
      hitdamage=25.000000
      AltHitDamage=100.000000
      AltAmmoUsed=10
-     RecoilKick=750.000000
-     RecoilLift=250.000000
-     bAltFireDropsFlag=True
+     RecoilKick=200.000000
+     RecoilLift=150.000000
      WeaponDescription="Classification: Energy Rifle"
      InstFlash=-0.400000
      InstFog=(Z=800.000000)
@@ -357,7 +356,7 @@ defaultproperties
      PickupViewMesh=LodMesh'WFMedia.hyperpick'
      ThirdPersonMesh=LodMesh'WFMedia.hyperthird'
      ThirdPersonScale=0.240000
-     StatusIcon=Texture'Botpack.Icons.UseASMD'
+     StatusIcon=Texture'WFMedia.WeaponHyperblaster'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.UseASMD'
      Mesh=LodMesh'WFMedia.hyperpick'
diff --git a/WFCode/Classes/WFInfiltrator.uc b/WFCode/Classes/WFInfiltrator.uc
index 4d1721e..921fcb0 100644
--- a/WFCode/Classes/WFInfiltrator.uc
+++ b/WFCode/Classes/WFInfiltrator.uc
@@ -123,13 +123,13 @@ defaultproperties
      TranslocatorAmmoUsed=10
      bNoImpactHammer=True
      bNoEnforcer=True
-     bCanIdentify=False
      ClassName="Infiltrator"
      ClassNamePlural="Infiltrators"
      MeshInfo=Class'WFSystem.WFD_TMale2MeshInfo'
      AltMeshInfo=Class'WFSystem.WFD_TMale2BotMeshInfo'
      DefaultInventory=Class'WFCode.WFInfiltratorInv'
      bAllowFeignDeath=True
+     ExtendedHUD=Class'WFCode.WFInfiltratorHUDInfo'
      HUDMenu=Class'WFCode.WFInfiltratorHUDMenu'
      Armor=50
      ClassDescription="WFCode.WFClassHelpInfiltrator"
diff --git a/WFCode/Classes/WFInfiltratorHUDInfo.uc b/WFCode/Classes/WFInfiltratorHUDInfo.uc
index 142cef6..654f5f9 100644
--- a/WFCode/Classes/WFInfiltratorHUDInfo.uc
+++ b/WFCode/Classes/WFInfiltratorHUDInfo.uc
@@ -1,43 +1,70 @@
-class WFInfiltratorHUDInfo extends WFHUDInfo;
+class WFInfiltratorHUDInfo extends WFCustomHUDInfo;
 
 var() texture CustomIconTexture;
 
 // could make this a general use function and move to WFHUDInfo and WFITSHUDInfo
 simulated function DrawStatus(out byte bOverrideFunction, Canvas Canvas)
 {
-	local bool bHasDoll;
-	local float X, Y, StatScale;
-	local int IconValue;
+  local byte         Style;
+	local color        DigitBackground;
+  local texture      DigitTexure;
+  local int          ResourceAmount;
+  local WFCustomHUD MyOwnerHUD;
+  local float H1, H2;
 
-	IconValue = GetIconValue();
+  MyOwnerHUD = WFCustomHUD( OwnerHUD );
 
-	if (!OwnerHUD.bHideStatus)
+  // Preserve the current style
+  Style = Canvas.Style;
+
+  Canvas.SetPos( Canvas.ClipX - ( 128 * MyOwnerHUD.MyStatusScale ),
+	               68 * MyOwnerHUD.MyStatusScale );
+
+  MyOwnerHUD.DrawPanel( Canvas,
+                        MyOwnerHUD.EPanel.PLeft,
+                        ERenderStyle.STY_Modulated,
+                        32, 32, MyOwnerHUD.HUDColor,
+												MyOwnerHUD.MyOpacity,
+                        MyOwnerHUD.MyStatusScale );
+  MyOwnerHUD.DrawPanel( Canvas,
+                        MyOwnerHUD.EPanel.PMiddle,
+	                      ERenderStyle.STY_Modulated,
+	                      96, 32, MyOwnerHUD.HUDColor,
+												MyOwnerHUD.MyOpacity,
+	                      MyOwnerHUD.MyStatusScale );
+
+   ResourceAmount = GetIconValue();
+   if( ResourceAmount < 0 )
+     ResourceAmount = 0;
+
+	if (ResourceAmount == 0)
 	{
-		bHasDoll = !(Canvas.ClipX < 400);
-		if (bHasDoll)
-			StatScale = OwnerHUD.Scale * OwnerHUD.StatusScale;
+		// make the colour flash
+		H1 = 1.5 * MyOwnerHUD.TutIconBlink;
+		H2 = 1 - H1;
+		Canvas.DrawColor = MyOwnerHUD.BaseColor * H2 + (MyOwnerHUD.HUDColor - MyOwnerHUD.BaseColor) * H1;
 	}
+	else Canvas.DrawColor = MyOwnerHUD.HUDColor;
+	 Canvas.Style = MyOwnerHUD.MySolidStyle;
 
-	// draw the hud icon
-	Canvas.DrawColor = OwnerHUD.HUDColor;
-	if ( OwnerHUD.bHideStatus && OwnerHUD.bHideAllWeapons )
-	{
-		//X = 0.5 * Canvas.ClipX;
-		//Y = Canvas.ClipY - 128 * OwnerHUD.Scale;
-		X = Canvas.ClipX - 128 * OwnerHUD.Scale;
-		Y = 0;
-	}
-	else
-	{
-		X = Canvas.ClipX - 128 * StatScale - 140 * OwnerHUD.Scale;
-		Y = 128 * OwnerHUD.Scale; // Y=0 for armor, Y=64 for health
-	}
-	Canvas.SetPos(X,Y);
-	Canvas.DrawTile(CustomIconTexture, 128*OwnerHUD.Scale, 64*OwnerHUD.Scale, 0, 0, 128.0, 64.0);
+   Canvas.SetPos( Canvas.ClipX - ( 110 * MyOwnerHUD.MyStatusScale ),
+	                68 * MyOwnerHUD.MyStatusScale );
+   Canvas.DrawTile( Texture'ResourceIcon', 32 * MyOwnerHUD.MyStatusScale,
+	                  32 * MyOwnerHUD.MyStatusScale, 0, 0, 32.0, 32.0);
+
+
+   Canvas.SetPos( Canvas.ClipX - ( 72 * MyOwnerHUD.MyStatusScale ),
+	                68 * MyOwnerHUD.MyStatusScale );
+   MyOwnerHUD.DrawDigits( Canvas,
+                          ResourceAmount,
+						              3,
+						              MyOwnerHUD.HUDColor,
+						              MyOwnerHUD.HUDBackgroundColor,
+						              MyOwnerHUD.MySolidStyle,
+						              ERenderStyle.STY_Translucent,
+									  MyOwnerHUD.MyStatusScale,
+									  (resourceAmount <= 0));
 
-	// draw the value for the icon
-	Canvas.DrawColor = OwnerHUD.WhiteColor;
-	OwnerHUD.DrawBigNum(Canvas, Max(0,IconValue), X + 4 * OwnerHUD.Scale, Y + 16 * OwnerHUD.Scale, 1);
 }
 
 function int GetIconValue()
diff --git a/WFCode/Classes/WFKamiWave.uc b/WFCode/Classes/WFKamiWave.uc
index ddf7ae2..9487b09 100644
--- a/WFCode/Classes/WFKamiWave.uc
+++ b/WFCode/Classes/WFKamiWave.uc
@@ -1,10 +1,9 @@
 class WFKamiWave extends WFPlasmaWave;
 
-simulated function Timer()
-{
-	// don't cause any damage
-}
-
 defaultproperties
 {
+     DamageType=KamikazeStatus
+     BaseDamage=250.000000
+     WaveScale=0.580000
+     LifeSpan=1.000000
 }
diff --git a/WFCode/Classes/WFLaserTripMineModule.uc b/WFCode/Classes/WFLaserTripMineModule.uc
index 6caeb00..e93a09a 100644
--- a/WFCode/Classes/WFLaserTripMineModule.uc
+++ b/WFCode/Classes/WFLaserTripMineModule.uc
@@ -19,16 +19,20 @@ var PlayerReplicationInfo OwnerPRI;
 
 var bool bAlreadyExploded;
 
+var byte CurrentBeamSize, SavedBeamSize;
+
+var float LastBeamCheck, BeamCheckRate;
+
 replication
 {
 	reliable if (Role == ROLE_Authority)
 		RealRotR, RealRotY, RealRotP, RealLocX, RealLocY, RealLocZ, BasedWall;
 	reliable if (Role == ROLE_Authority)
-		/*TeamTexture,*/ bAlreadyDestroyed, /*bActivateAlertSent,*/ bWantsToFlicker;
+		bAlreadyDestroyed, bWantsToFlicker;
 
 	// Ob1: just to be safe, the clientside beam waits for this to be replicated
 	reliable if (Role == ROLE_Authority)
-		OwnerPRI;
+		OwnerPRI, CurrentBeamSize;
 }
 
 
@@ -63,6 +67,13 @@ simulated function Tick(float DeltaTime)
 	{
 		CreateBeam();
 	}
+
+	// adjust length of beam if necessary
+	if (HeadBeam != None)
+	{
+		CheckBeamSize();
+		AdjustBeamSize();
+	}
 }
 
 simulated state Flickering
@@ -267,6 +278,14 @@ simulated function CreateBeam()
 	//log (Self$": Linked Final"@TailBeam$".PrevBeam to "@LastBeam);
 	LastBeam.NextBeam = TailBeam;
 	//log (Self$": Linked Final"@LastBeam$".NextBeam to "@TailBeam);
+
+	// New: 14-09-2001
+	// -- Ob1: added to help with dynamically adjusting beam size
+	if (Role == ROLE_Authority)
+		CurrentBeamSize = BeamCtr + 1; // segment count + head segment
+	SavedBeamSize = BeamCtr + 1; // client side stored value
+	// End: 14-09-2001
+
 	if ( HeadBeam == None || TailBeam == None || !bAtLeastOneBeamAdded )
 	{
 		if ( HeadBeam != None )
@@ -297,6 +316,138 @@ simulated function ReceiveAlert( string AlertType, int Dir, actor Blah)
 	}
 }
 
+// New: 14-09-2001
+// -- Ob1: added to help with dynamically adjusting beam size
+function CheckBeamSize()
+{
+	local vector HitNorm, HitLoc, Start, End;
+	local actor HitActor;
+	local bool bHitWall;
+
+	// server side length adjustment
+	if ((Level.TimeSeconds - LastBeamCheck) < BeamCheckRate)
+		return;
+
+	LastBeamCheck = Level.TimeSeconds;
+
+	Start = Location;
+	End = BeamSize*vector(rotation)*MaxSegments + Start;
+	foreach TraceActors(class'Actor', HitActor, HitLoc, HitNorm, End, Start)
+	{
+		if ((Brush(HitActor) != None) || (HitActor == Level))
+		{
+			Log("Hit Wall: "$Hitactor);
+			bHitWall = true;
+			break;
+		}
+	}
+
+	if (bHitWall)
+		CurrentBeamSize = int(VSize(HitLoc - Start)/BeamSize);
+	else CurrentBeamSize = MaxSegments;
+
+	if (CurrentBeamSize == 2)
+	{
+		// module's beam is too small
+		CurrentBeamSize = 0;
+		Disable('Tick');
+		spawn(class'EnhancedRespawn', self,, Location);
+		Destroy();
+	}
+}
+
+simulated function AdjustBeamSize()
+{
+	local int Num;
+	local WFLaserTripmineBeam ThisBeam, LastBeam;
+	local WFLaserTripmineBeamTail Tail;
+	local vector BeamLoc, Offset;
+	local rotator BeamRot;
+	local bool bBeamActive;
+
+	if (CurrentBeamSize == 0)
+		return; // authoritive beam size not yet reached the client
+
+	if (bDeleteMe)
+	{
+		Disable('Tick');
+		return;
+	}
+
+	// deal with adjusting the beam length
+	if (SavedBeamSize != CurrentBeamSize)
+	{
+		// update size of beam
+		Num = CurrentBeamSize - SavedBeamSize;
+		//Log("AdjustBeamSize(): Num: "$Num);
+		bBeamActive = HeadBeam.bActive;
+		if (Num > 0)
+		{
+			// add Num segments
+			Tail = TailBeam;
+			LastBeam = TailBeam.PrevBeam;
+			Offset = vector(Rotation)*BeamSize;
+			BeamLoc = LastBeam.Location + Offset;
+			while (Num > 0)
+			{
+				//Log("AdjustBeamSize(): Creating new segment at: "$BeamLoc);
+				ThisBeam = spawn(class'WFLaserTripmineBeam', Self,, BeamLoc, Rotation);
+				if (bBeamActive)
+					ThisBeam.ProcessAlert("activate", self);
+				ThisBeam.OwnerPRI = OwnerPRI;
+				LastBeam.NextBeam = ThisBeam;
+				ThisBeam.PrevBeam = LastBeam;
+				LastBeam = ThisBeam;
+				BeamLoc += Offset;
+				Num--;
+			}
+			ThisBeam.NextBeam = TailBeam;
+			TailBeam.PrevBeam = ThisBeam;
+			// re-create tail cap effect if necessary
+			if (TailBeam.TailFX != None)
+			{
+				TailBeam.TailFX.Destroy();
+				TailBeam.TailFX = None;
+			}
+			TailBeam.SetLocation(BeamLoc);
+			if (CurrentBeamSize == MaxSegments)
+				TailBeam.AddTail( BeamLoc + Offset, Rotation );
+		}
+		else if (Num < 0)
+		{
+			// remove Num segments
+			ThisBeam = TailBeam.PrevBeam;
+			while (Num < 0)
+			{
+				//Log("AdjustBeamSize(): Removing segment: "$ThisBeam);
+				LastBeam = ThisBeam;
+				ThisBeam = ThisBeam.PrevBeam;
+				if (LastBeam != HeadBeam)
+					LastBeam.Destroy();
+				else Log("WARNING: attempted to destroy head beam!");
+				Num++;
+			}
+			BeamLoc = ThisBeam.Location + vector(rotation)*BeamSize;
+			ThisBeam.NextBeam = TailBeam;
+			TailBeam.PrevBeam = ThisBeam;
+			// remove tail cap effect, since its obviously not max length now
+			if (TailBeam.TailFX != None)
+			{
+				TailBeam.TailFX.Destroy();
+				TailBeam.TailFX = None;
+			}
+			TailBeam.SetLocation(BeamLoc);
+		}
+	}
+
+	SavedBeamSize = CurrentBeamSize;
+}
+
+event FellOutOfWorld()
+{
+}
+// End: 14-09-2001
+
 defaultproperties
 {
      BeamSize=24.299999
@@ -314,6 +465,7 @@ defaultproperties
      RealRotR=-1
      RealRotY=-1
      RealRotP=-1
+     BeamCheckRate=0.125000
      Damage=75.000000
      ImpactSound=Sound'UnrealShare.Eightball.GrenadeFloor'
      bAlwaysRelevant=True
@@ -325,7 +477,7 @@ defaultproperties
      SoundRadius=20
      SoundVolume=100
      CollisionRadius=2.000000
-     CollisionHeight=5.000000
+     CollisionHeight=2.000000
      bProjTarget=True
      bBounce=True
      Mass=50.000000
diff --git a/WFCode/Classes/WFLaserTripmineBeam.uc b/WFCode/Classes/WFLaserTripmineBeam.uc
index f974447..aa76a4d 100644
--- a/WFCode/Classes/WFLaserTripmineBeam.uc
+++ b/WFCode/Classes/WFLaserTripmineBeam.uc
@@ -41,7 +41,9 @@ function Touch( actor Other )
 	}
 	if ( bActive && (Other != None) && Other.bIsPawn && !IsCloaked(pawn(Other)) && (Pawn(Other).PlayerReplicationInfo != None)) // Other.bIsPawn covers (WFLaserTripmine(Owner) == None)
 	{
-		if (!class'WFDisguise'.static.IsDisguised(pawn(Other).PlayerReplicationInfo) && (OwnerPRI.Team != pawn(Other).PlayerReplicationInfo.Team))
+		//if (!class'WFDisguise'.static.IsDisguised(pawn(Other).PlayerReplicationInfo) && (OwnerPRI.Team != pawn(Other).PlayerReplicationInfo.Team))
+		if ( (IsHalfCloaked(pawn(Other)) || !class'WFDisguise'.static.IsDisguised(pawn(Other).PlayerReplicationInfo))
+			&& (OwnerPRI.Team != pawn(Other).PlayerReplicationInfo.Team))
 		{
 			bWaitForNextTickToSendDestroy = true;
 			PendingOther = Other;
@@ -65,7 +67,12 @@ function Touch( actor Other )
 // returns true if player is cloaked
 function bool IsCloaked(pawn Other)
 {
-	return (Other.bMeshEnviroMap && (Other.Texture == FireTexture'Unrealshare.Belt_fx.Invis'));
+	return (Other == None) || (Other.bMeshEnviroMap && (Other.Texture == FireTexture'Unrealshare.Belt_fx.Invis'));
+}
+
+function bool IsHalfCloaked(pawn Other)
+{
+	return (Other == None) || (Other.bMeshEnviroMap && (Other.Texture == Texture'JDomN0'));
 }
 
 simulated function DoCleanUp()
diff --git a/WFCode/Classes/WFMachineGun.uc b/WFCode/Classes/WFMachineGun.uc
index 9000045..1725e35 100644
--- a/WFCode/Classes/WFMachineGun.uc
+++ b/WFCode/Classes/WFMachineGun.uc
@@ -195,6 +195,7 @@ function Fire( float Value )
 	}
 	if ( AmmoType.UseAmmo(1) )
 	{
+		NotifyFired();
 		SoundVolume = 255*Pawn(Owner).SoundDampening;
 		Pawn(Owner).PlayRecoil(FiringSpeed);
 		bCanClientFire = true;
@@ -219,6 +220,7 @@ function AltFire( float Value )
 	}
 	if ( AmmoType.UseAmmo(1) )
 	{
+		NotifyFired();
 		bPointing=True;
 		bCanClientFire = true;
 		ShotAccuracy = 0.95;
@@ -561,10 +563,10 @@ defaultproperties
      AIRating=0.730000
      RefireRate=0.990000
      AltRefireRate=0.990000
-     FireSound=Sound'Botpack.minigun2.M2RegFire'
-     AltFireSound=Sound'Botpack.minigun2.M2AltFire'
+     FireSound=Sound'Botpack.Minigun2.M2RegFire'
+     AltFireSound=Sound'Botpack.Minigun2.M2AltFire'
      SelectSound=Sound'UnrealI.Minigun.MiniSelect'
-     Misc1Sound=Sound'Botpack.minigun2.M2WindDown'
+     Misc1Sound=Sound'Botpack.Minigun2.M2WindDown'
      DeathMessage="%k's %w turned %o into a leaky piece of meat."
      NameColor=(B=0)
      bDrawMuzzleFlash=True
@@ -584,7 +586,7 @@ defaultproperties
      BobDamping=0.975000
      PickupViewMesh=LodMesh'Botpack.MinigunPick'
      ThirdPersonMesh=LodMesh'Botpack.MiniHand'
-     StatusIcon=Texture'Botpack.Icons.UseMini'
+     StatusIcon=Texture'WFMedia.WeaponMachineGun'
      bMuzzleFlashParticles=True
      MuzzleFlashStyle=STY_Translucent
      MuzzleFlashMesh=LodMesh'Botpack.MuzzFlash3'
diff --git a/WFCode/Classes/WFMedKit.uc b/WFCode/Classes/WFMedKit.uc
index 1b7cd47..bd16607 100644
--- a/WFCode/Classes/WFMedKit.uc
+++ b/WFCode/Classes/WFMedKit.uc
@@ -8,11 +8,14 @@ var() int HealAmount;
 
 var pawn MedKitTarget;
 
+var WFMasterEffect MyEffect;
+
 function Fire( float Value )
 {
 	if (!WeaponActive())
 		return;
 
+	NotifyFired();
 	bPointing=True;
 	bCanClientFire = true;
 	AmbientSound = FireSound;
@@ -21,12 +24,36 @@ function Fire( float Value )
 	//else MedBeam.bHidden = false;
 	SoundVolume = 255*Pawn(Owner).SoundDampening;
 	ClientFire(value);
-	GoToState('NormalFire');
+	GoToState('FireDelay');
+}
+
+simulated state FireDelay
+{
+	function Fire(float Value) { }
+	function AltFire(float Value) { }
+	function bool ClientFire(float value) { return false; }
+	function bool ClientAltFire(float value) { return false; }
+
+Begin:
+	Disable('AnimEnd');
+	PlayStartFiring();
+	FinishAnim();
+	Enable('AnimEnd');
+	PlayFiring();
+	if (Role==ROLE_Authority)
+		GotoState('NormalFire');
+	else GotoState('ClientFiring');
+}
+
+simulated function PlayStartFiring()
+{
+	PlayAnim('Vaccinate', 0.4, 0.1);
 }
 
 simulated function PlayAltFiring()
 {
-	PlayAnim('Fire', 0.5);
+	//PlayAnim('Vaccinate', 0.5);
+	PlayAnim('Vaccinate', 0.3);
 	PlayOwnedSound(AltFireSound, SLOT_Misc, 1.7*Pawn(Owner).SoundDampening,,,);
 }
 
@@ -35,7 +62,7 @@ simulated function PlayFiring()
 	if ( Affector != None )
 		Affector.FireEffect();
 	//PlayOwnedSound(AltFireSound, SLOT_Misc, 1.7*Pawn(Owner).SoundDampening,,,);
-	LoopAnim( 'Shake', 0.9);
+	LoopAnim( 'Heal', 0.4);
 }
 
 function AltFire( float Value )
@@ -67,6 +94,13 @@ ignores AnimEnd;
 		super.BeginState();
 		SetTimer(HealTime, false);
 		AmbientSound = FireSound;
+		if (MyEffect == None)
+		{
+			if (Pawn(Owner).PlayerReplicationInfo.Team == 0)
+				MyEffect = spawn(class'WFMedKitFieldEffectRed', owner,, owner.Location);
+			else
+				MyEffect = spawn(class'WFMedKitFieldEffectBlue', owner,, owner.Location);
+		}
 	}
 
 	function Timer()
@@ -88,6 +122,11 @@ ignores AnimEnd;
 	{
 		SetTimer(0.0, false);
 		AmbientSound = None;
+		if (MyEffect != None)
+		{
+			MyEffect.Destroy();
+			MyEffect = None;
+		}
 		super.EndState();
 	}
 }
@@ -106,17 +145,14 @@ function HealTarget(pawn Other)
 	local effects e;
 	local int MaxHealth;
 
-	if (ValidTarget(Other))
+	MaxHealth = GetMaxHealthFor(Other);
+	if (Other.Health < MaxHealth)
 	{
-		MaxHealth = GetMaxHealthFor(Other);
-		if (Other.Health < MaxHealth)
-		{
-			Other.Health = Min(Other.Health + HealAmount, MaxHealth);
-			e = Spawn(class'WFMedKitHealEffect', Other,, Other.Location);
-			e.Mesh = Other.Mesh;
-		}
-		CurePlayer(Other);
+		Other.Health = Min(Other.Health + HealAmount, MaxHealth);
+		e = Spawn(class'WFMedKitHealEffect', Other,, Other.Location);
+		e.Mesh = Other.Mesh;
 	}
+	CurePlayer(Other);
 }
 
 // remove any bad status effects
@@ -174,6 +210,27 @@ function int GetMaxHealthFor(pawn Other)
 
 state ClientFiring
 {
+	simulated function bool ClientFire( float Value )
+	{
+		if ( bCanClientFire && ((Role == ROLE_Authority) || (AmmoType == None) || (AmmoType.AmmoAmount > 0)) )
+		{
+			if ( (PlayerPawn(Owner) != None)
+				&& ((Level.NetMode == NM_Standalone) || PlayerPawn(Owner).Player.IsA('ViewPort')) )
+			{
+				if ( InstFlash != 0.0 )
+					PlayerPawn(Owner).ClientInstantFlash( InstFlash, InstFog);
+				PlayerPawn(Owner).ShakeView(ShakeTime, ShakeMag, ShakeVert);
+			}
+			if ( Affector != None )
+				Affector.FireEffect();
+			PlayFiring();
+			if ( Role < ROLE_Authority )
+				GotoState('ClientFiring');
+			return true;
+		}
+		return false;
+	}
+
 	simulated function BeginState()
 	{
 		SoundVolume = 255*Pawn(Owner).SoundDampening;
@@ -189,8 +246,8 @@ function bool ValidTarget(pawn Other)
 	GetAxes(Pawn(owner).ViewRotation, X, Y, Z);
 	if ((Other != None) && (Other != Owner) && Other.bIsPlayer && (Other.Health > 0)
 		&& (VSize(Other.Location - Owner.Location) <= MedBeamRange)
-		&& (Other.PlayerReplicationInfo.Team == pawn(Owner).PlayerReplicationInfo.Team)
-		&& ((Normal(Other.Location - Owner.Location) dot X) > 0.7) )
+		&& (Other.PlayerReplicationInfo.Team == pawn(Owner).PlayerReplicationInfo.Team) )
+		//&& ((Normal(Other.Location - Owner.Location) dot X) > 0.7) )
 		return true;
 
 	return false;
@@ -275,6 +332,16 @@ function ProcessTraceHit(Actor Other, Vector HitLocation, Vector HitNormal, Vect
 	}
 }
 
+simulated function Destroyed()
+{
+	if (MyEffect != None)
+	{
+		MyEffect.Destroy();
+		MyEffect = None;
+	}
+	super.Destroyed();
+}
+
 defaultproperties
 {
      CureStatusTypes(0)="Infected"
@@ -282,9 +349,9 @@ defaultproperties
      CureStatusTypes(2)="Blinded"
      CureStatusTypes(3)="Tranquilised"
      CureStatusTypes(4)="Leg damage"
-     MedBeamRange=180.000000
+     MedBeamRange=215.000000
      HealTime=1.000000
-     HealAmount=10
+     HealAmount=20
      bAltInstantHit=True
      FireOffset=(Y=-15.000000,Z=-13.000000)
      AltProjectileClass=Class'WFCode.WFMedKitGasPuff'
@@ -293,17 +360,15 @@ defaultproperties
      DeathMessage="%o was killed by %k's toxic gas"
      AutoSwitchPriority=2
      InventoryGroup=2
-     PlayerViewOffset=(X=3.800000,Y=-1.600000,Z=-1.800000)
-     PlayerViewMesh=LodMesh'Botpack.ImpactHammer'
-     PickupViewMesh=LodMesh'Botpack.ImpPick'
-     ThirdPersonMesh=LodMesh'Botpack.ImpactHandm'
+     ItemName="Med Kit"
+     PlayerViewOffset=(X=2.400000,Y=-1.200000,Z=-1.950000)
+     PlayerViewMesh=LodMesh'WFMedia.medkit'
+     PlayerViewScale=0.100000
+     PickupViewMesh=LodMesh'WFMedia.medthird'
+     ThirdPersonMesh=LodMesh'WFMedia.medthird'
      ThirdPersonScale=0.500000
-     StatusIcon=Texture'Botpack.Icons.UseHammer'
-     PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
-     Icon=Texture'Botpack.Icons.UseHammer'
+     StatusIcon=Texture'WFMedia.WeaponMedKit'
      Texture=Texture'Botpack.Skins.JDomN0'
-     Mesh=LodMesh'Botpack.ImpPick'
-     bMeshEnviroMap=True
      SoundRadius=50
      Mass=20.000000
 }
diff --git a/WFCode/Classes/WFMedKitGasPuff.uc b/WFCode/Classes/WFMedKitGasPuff.uc
index e1a84d2..fed9bdd 100644
--- a/WFCode/Classes/WFMedKitGasPuff.uc
+++ b/WFCode/Classes/WFMedKitGasPuff.uc
@@ -19,6 +19,7 @@ function CauseDamage(pawn Other, vector HitLocation)
 	local class<WFPlayerClassInfo> PCI;
 	local WFStatusInfected s;
 	local bool bGiveStatus;
+	local WFPlayer WFP;
 
 	if ((Role != ROLE_Authority) || (Other == None))
 		return;
@@ -28,8 +29,10 @@ function CauseDamage(pawn Other, vector HitLocation)
 		Other.TakeDamage(5, Instigator, HitLocation, vect(0,0,0), 'Gassed');
 		if (Other.Health > 0)
 		{
-			PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
-			bGiveStatus = ((PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusInfected'))
+			//WFP = WFPlayer(Other);
+			//PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
+			//bGiveStatus = ((PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusInfected'))
+			bGiveStatus = !class'WFPlayerClassInfo'.static.PawnIsImmuneTo(Other, class'WFStatusInfected')
 				&& (Other.FindInventoryType(class'WFStatusVaccinated') == None);
 			bGiveStatus = bGiveStatus && (Other.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team);
 			if (bGiveStatus && (FRand() <= InfectOdds))
diff --git a/WFCode/Classes/WFMiniChunk.uc b/WFCode/Classes/WFMiniChunk.uc
index 88ba98e..8fc1b0e 100644
--- a/WFCode/Classes/WFMiniChunk.uc
+++ b/WFCode/Classes/WFMiniChunk.uc
@@ -27,6 +27,6 @@ simulated function PostBeginPlay()
 
 defaultproperties
 {
-     Damage=8.000000
+     Damage=12.000000
      DrawScale=0.100000
 }
diff --git a/WFCode/Classes/WFMiniFlak.uc b/WFCode/Classes/WFMiniFlak.uc
index 52797b4..e516fd3 100644
--- a/WFCode/Classes/WFMiniFlak.uc
+++ b/WFCode/Classes/WFMiniFlak.uc
@@ -110,6 +110,7 @@ function Fire( float Value )
 	}
 	if (AmmoType.UseAmmo(1))
 	{
+		NotifyFired();
 		bCanClientFire = true;
 		bPointing=True;
 		Start = Owner.Location + CalcDrawOffset();
@@ -165,6 +166,7 @@ function AltFire( float Value )
 	}
 	if (AmmoType.UseAmmo(1))
 	{
+		NotifyFired();
 		Pawn(Owner).PlayRecoil(FiringSpeed);
 		bPointing=True;
 		bCanClientFire = true;
@@ -386,7 +388,7 @@ defaultproperties
      PickupViewScale=0.625000
      ThirdPersonMesh=LodMesh'Botpack.FlakHand'
      ThirdPersonScale=0.625000
-     StatusIcon=Texture'Botpack.Icons.UseFlak'
+     StatusIcon=Texture'WFMedia.WeaponMiniFlak'
      bMuzzleFlashParticles=True
      MuzzleFlashStyle=STY_Translucent
      MuzzleFlashMesh=LodMesh'Botpack.muzzFF3'
diff --git a/WFCode/Classes/WFMotionBlurEffect.uc b/WFCode/Classes/WFMotionBlurEffect.uc
index 75d60d1..750e878 100644
--- a/WFCode/Classes/WFMotionBlurEffect.uc
+++ b/WFCode/Classes/WFMotionBlurEffect.uc
@@ -5,8 +5,9 @@ class WFMotionBlurEffect extends Effects;
 
 var() float FadeScale;	// the larger the value, the shorter the effect lasts
 var() float FinalScaleGlow;
+var() sound SpawnEffectSound;
 
-function PostBeginPlay()
+simulated function PostBeginPlay()
 {
 	Enable('Tick');
 }
diff --git a/WFCode/Classes/WFMotionBlurGenerator.uc b/WFCode/Classes/WFMotionBlurGenerator.uc
index 116bc4b..9539670 100644
--- a/WFCode/Classes/WFMotionBlurGenerator.uc
+++ b/WFCode/Classes/WFMotionBlurGenerator.uc
@@ -27,7 +27,8 @@ simulated function Tick(float DeltaTime)
 {
 	local WFMotionBlurEffect Blur;
 
-	if (bHidden) return;
+	if (!ShouldCreateEffect())
+		return;
 
 	if (Level.NetMode == NM_DedicatedServer)
 	{
@@ -46,6 +47,11 @@ simulated function Tick(float DeltaTime)
 	}
 }
 
+simulated function bool ShouldCreateEffect()
+{
+	return !bHidden; // override to define extra rules for creating the effect blur
+}
+
 simulated function DLog(coerce string S, float Delay)
 {
 	if ((Level.TimeSeconds - LastLog) > Delay)
diff --git a/WFCode/Classes/WFMutator.uc b/WFCode/Classes/WFMutator.uc
index 54baacc..c3525da 100644
--- a/WFCode/Classes/WFMutator.uc
+++ b/WFCode/Classes/WFMutator.uc
@@ -1,5 +1,7 @@
 class WFMutator extends DMMutator;
 
+var bool bRegistered;
+
 function bool AlwaysKeep(Actor Other)
 {
 	local bool bTemp;
@@ -39,6 +41,47 @@ function CreateInventoryMarkerFor(inventory Item)
 	}
 }
 
+function Tick(float DeltaTime)
+{
+	if (!bRegistered)
+	{
+		Level.Game.RegisterMessageMutator(self);
+		bRegistered = True;
+		Disable('Tick');
+	}
+}
+
+// catch and filter mesage broadcasts
+function bool MutatorBroadcastLocalizedMessage( Actor Sender, Pawn Receiver, out class<LocalMessage> Message, out optional int Switch, out optional PlayerReplicationInfo RelatedPRI_1, out optional PlayerReplicationInfo RelatedPRI_2, out optional Object OptionalObject )
+{
+	local actor theOwner;
+
+	for (theOwner=Sender; theOwner!=None; theOwner=theOwner.Owner)
+		if (theOwner.IsA('PlayerPawn') && (NetConnection(playerpawn(theOwner).Player)!=None))
+			return false; // quietly filter out the attempt
+
+	if ( NextMessageMutator != None )
+		return NextMessageMutator.MutatorBroadcastLocalizedMessage( Sender, Receiver, Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );
+	else
+		return true;
+}
+
+function bool MutatorBroadcastMessage( Actor Sender, Pawn Receiver, out coerce string Msg, optional bool bBeep, out optional name Type )
+{
+	local actor theOwner;
+	local string IP;
+	local int j;
+
+	for (theOwner=Sender; theOwner!=None; theOwner=theOwner.Owner)
+		if (theOwner.IsA('PlayerPawn') && (NetConnection(playerpawn(theOwner).Player)!=None))
+			return false; // quietly filter out the message
+
+	if ( NextMessageMutator != None )
+		return NextMessageMutator.MutatorBroadcastMessage( Sender, Receiver, Msg, bBeep, Type );
+	else
+		return true;
+}
+
 defaultproperties
 {
 }
diff --git a/WFCode/Classes/WFNapalmGrenade.uc b/WFCode/Classes/WFNapalmGrenade.uc
index 56fcb2d..7285ea0 100644
--- a/WFCode/Classes/WFNapalmGrenade.uc
+++ b/WFCode/Classes/WFNapalmGrenade.uc
@@ -51,6 +51,7 @@ function BlowUp(vector HitLocation)
 	local WFStatusOnFire s;
 	local bool bGiveStatus;
 	local class<WFPlayerClassInfo> PCI;
+	local WFPlayer WFP;
 
 	if( bHurtEntry )
 		return;
@@ -81,8 +82,10 @@ function BlowUp(vector HitLocation)
 				aPawn = pawn(Victims);
 				if (aPawn.bIsPlayer && (aPawn.Health > 0))
 				{
-					PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
-					bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+					//WFP = WFPlayer(aPawn);
+					//PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
+					//bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+					bGiveStatus = !class'WFPlayerClassInfo'.static.PawnIsImmuneTo(aPawn, class'WFStatusOnFire');
 
 					if (bGiveStatus && (aPawn.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team))
 					{
diff --git a/WFCode/Classes/WFNapalmRL.uc b/WFCode/Classes/WFNapalmRL.uc
index 8f9271a..7aafc68 100644
--- a/WFCode/Classes/WFNapalmRL.uc
+++ b/WFCode/Classes/WFNapalmRL.uc
@@ -141,7 +141,7 @@ defaultproperties
      BobDamping=0.975000
      PickupViewMesh=LodMesh'Botpack.Eight2Pick'
      ThirdPersonMesh=LodMesh'Botpack.EightHand'
-     StatusIcon=Texture'Botpack.Icons.Use8ball'
+     StatusIcon=Texture'WFMedia.WeaponNapalmRocketLauncher'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.Use8ball'
      Mesh=LodMesh'Botpack.Eight2Pick'
diff --git a/WFCode/Classes/WFNapalmRocket.uc b/WFCode/Classes/WFNapalmRocket.uc
index a1f1cb2..558a4db 100644
--- a/WFCode/Classes/WFNapalmRocket.uc
+++ b/WFCode/Classes/WFNapalmRocket.uc
@@ -13,6 +13,7 @@ auto state Flying
 		local WFStatusOnFire s;
 		local bool bGiveStatus;
 		local class<WFPlayerClassInfo> PCI;
+		local WFPlayer WFP;
 
 		if( bHurtEntry )
 			return;
@@ -43,8 +44,10 @@ auto state Flying
 					aPawn = pawn(Victims);
 					if (aPawn.bIsPlayer && (aPawn.Health > 0))
 					{
-						PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
-						bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+						//WFP = WFPlayer(aPawn);
+						//PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
+						//bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+						bGiveStatus = !class'WFPlayerClassInfo'.static.PawnIsImmuneTo(aPawn, class'WFStatusOnFire');
 
 						if (bGiveStatus && (aPawn.PlayerReplicationInfo.Team != Instigator.PlayerReplicationInfo.Team))
 						{
diff --git a/WFCode/Classes/WFPipeBomb.uc b/WFCode/Classes/WFPipeBomb.uc
index e17de5e..d2f55fc 100644
--- a/WFCode/Classes/WFPipeBomb.uc
+++ b/WFCode/Classes/WFPipeBomb.uc
@@ -1,6 +1,15 @@
 class WFPipeBomb extends WFS_PCSGrenadeProj;
 
 var int Health;
+var WFPipeBomb NextBomb;
+var WFPipeBombList List;
+
+function DetonateAll()
+{
+	if (NextBomb != None)
+		NextBomb.DetonateAll();
+	Detonate();
+}
 
 simulated function PostBeginPlay()
 {
@@ -20,7 +29,7 @@ simulated function PostBeginPlay()
 
 function TakeDamage( int Damage, Pawn EventInstigator, vector HitLocation, vector Momentum, name DamageType)
 {
-	if (Health <= 0)
+	if ((Health <= 0) || bDeleteMe)
 		return;
 
 	if ((EventInstigator == None) || EventInstigator.bIsPlayer)
@@ -30,8 +39,8 @@ function TakeDamage( int Damage, Pawn EventInstigator, vector HitLocation, vecto
 			Health -= Damage;
 		if (Health <= 0)
 		{
-			Detonate();
 			UpdateList();
+			Detonate();
 		}
 	}
 }
@@ -40,19 +49,20 @@ function ServerExplosion(vector HitLocation)
 {
 	BlowUp(HitLocation);
 	spawn(class'ut_spriteballexplosion',,,hitlocation);
-	//UpdateList();
 	Destroy();
 }
 
 function Detonate()
 {
-	ServerExplosion(Location + vect(0,0,16));
+	if (!bDeleteMe)
+	{
+		UpdateList();
+		ServerExplosion(Location + vect(0,0,16));
+	}
 }
 
 function UpdateList()
 {
-	local WFPipeBombList List;
-	List = WFPipeBombList(class'WFS_PlayerClassInfo'.static.FindRelatedActorClass(Instigator, class'WFPipeBombList'));
 	if (List != None)
 		List.RemovePipeBomb(self);
 }
diff --git a/WFCode/Classes/WFPipeBombLauncher.uc b/WFCode/Classes/WFPipeBombLauncher.uc
index 5bbf7bc..3ae7b0b 100644
--- a/WFCode/Classes/WFPipeBombLauncher.uc
+++ b/WFCode/Classes/WFPipeBombLauncher.uc
@@ -75,6 +75,7 @@ function Fire( float Value )
 	if ( AmmoType.UseAmmo(1) )
 	{
 		GotoState('NormalFire');
+		NotifyFired();
 		bPointing=True;
 		bCanClientFire = true;
 		ClientFire(Value);
@@ -98,6 +99,7 @@ function AltFire( float Value )
 
 	if (NumPipeBombs > 0)
 	{
+		NotifyFired();
 		GotoState('AltFiring');
 		bPointing=True;
 		bCanClientFire = true;
@@ -295,7 +297,7 @@ defaultproperties
      BobDamping=0.975000
      PickupViewMesh=LodMesh'WFMedia.plthird1'
      ThirdPersonMesh=LodMesh'WFMedia.plthird1'
-     StatusIcon=Texture'Botpack.Icons.Use8ball'
+     StatusIcon=Texture'WFMedia.WeaponPipeBombs'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.Use8ball'
      Mesh=LodMesh'WFMedia.plthird1'
diff --git a/WFCode/Classes/WFPipeBombList.uc b/WFCode/Classes/WFPipeBombList.uc
index 7b750ce..866519e 100644
--- a/WFCode/Classes/WFPipeBombList.uc
+++ b/WFCode/Classes/WFPipeBombList.uc
@@ -2,18 +2,18 @@ class WFPipeBombList extends WFS_PCSystemInfo;
 
 var() int MaxPipeBombs;
 var int NumPipeBombs;
-var WFPipeBomb PipeBombList[10];
+//var WFPipeBomb PipeBombList[10];
+var WFPipeBomb FirstPipeBomb;
 var WFPipeBombLauncher PBL;
 
 function DetPipes()
 {
-	local int i;
-	for (i=0; i<NumPipeBombs; i++)
-		if (PipeBombList[i] != None)
-		{
-			PipeBombList[i].Detonate();
-			PipeBombList[i] = None;
-		}
+	if (FirstPipeBomb != None)
+	{
+		FirstPipeBomb.DetonateAll();
+		FirstPipeBomb = None;
+	}
+
 	NumPipeBombs = 0;
 	if (PBL != None)
 		PBL.NumPipeBombs = 0;
@@ -21,53 +21,101 @@ function DetPipes()
 
 function AddPipeBomb(WFPipeBomb NewPipeBomb)
 {
-	local int i;
-	local WFPipeBomb b;
+	local WFPipeBomb pb;
 
 	if (NewPipeBomb == None)
 		return;
 
-	if (NumPipeBombs == MaxPipeBombs)
-	{
-		if (PipeBombList[0] != None)
-			PipeBombList[0].Detonate();
-
-		for (i=0; i<NumPipeBombs; i++)
-		{
-			if (i == NumPipeBombs-1)
-				PipeBombList[i] = NewPipeBomb;
-			else PipeBombList[i] = PipeBombList[i+1];
-		}
-	}
+	NewPipeBomb.List = self;
+	if (FirstPipeBomb == None)
+		FirstPipeBomb = NewPipeBomb;
 	else
 	{
-		NumPipeBombs++;
-		PipeBombList[NumPipeBombs-1] = NewPipeBomb;
+		NewPipeBomb.NextBomb = FirstPipeBomb;
+		FirstPipeBomb = NewPipeBomb;
 	}
 
+	NumPipeBombs++;
+	if (NumPipeBombs > MaxPipeBombs)
+	{
+		DetonateOldest();
+		NumPipeBombs = MaxPipeBombs;
+	}
 	if (PBL != None)
 		PBL.NumPipeBombs = NumPipeBombs;
 }
 
-function RemovePipeBomb(WFPipeBomb OldPipeBomb)
+function DetonateOldest()
 {
-	local int i, j;
-	for (i=0; i<NumPipeBombs; i++)
+	local WFPipeBomb pb, lastpb;
+
+	if (FirstPipeBomb == None)
+		return;
+
+	if (FirstPipeBomb.NextBomb == None)
 	{
-		if (PipeBombList[i] == OldPipeBomb)
+		FirstPipeBomb.Detonate();
+		FirstPipeBomb = None;
+		NumPipeBombs--;
+		if (PBL != None)
+			PBL.NumPipeBombs = NumPipeBombs;
+		return;
+	}
+
+	lastpb = FirstPipeBomb;
+	for (pb=FirstPipeBomb.NextBomb; pb!=None; pb=pb.NextBomb)
+	{
+		if (pb.NextBomb == None)
 		{
-			PipeBombList[i] = None;
-			for (j=i; j<NumPipeBombs; j++)
-			{
-				if (j == NumPipeBombs-1)
-					PipeBombList[j] = None;
-				else PipeBombList[j] = PipeBombList[j+1];
-			}
+			pb.Detonate();
+			if (lastpb != None)
+				lastpb.NextBomb = None;
 			NumPipeBombs--;
 			if (PBL != None)
 				PBL.NumPipeBombs = NumPipeBombs;
 			break;
 		}
+		lastpb = pb;
+	}
+}
+
+function RemovePipeBomb(WFPipeBomb OldPipeBomb)
+{
+	local WFPipeBomb pb, lastpb;
+	local bool bRemoved;
+
+	if ((FirstPipeBomb == None) || (OldPipeBomb == None))
+		return;
+
+	bRemoved = false;
+	if (OldPipeBomb == FirstPipeBomb)
+	{
+		pb = FirstPipeBomb.NextBomb;
+		FirstPipeBomb.NextBomb = None;
+		FirstPipeBomb = pb;
+		bRemoved = true;
+	}
+	else
+	{
+		for (pb=FirstPipeBomb; pb!=None; pb=pb.NextBomb)
+		{
+			if (pb == OldPipeBomb)
+			{
+				pb = OldPipeBomb.NextBomb;
+				if (lastpb != None)
+					lastpb.NextBomb = pb;
+				bRemoved = true;
+				break;
+			}
+			lastpb = pb;
+		}
+	}
+
+	if (bRemoved)
+	{
+		NumPipeBombs--;
+		if (PBL != None)
+			PBL.NumPipeBombs = NumPipeBombs;
 	}
 }
 
diff --git a/WFCode/Classes/WFPlasmaBomb.uc b/WFCode/Classes/WFPlasmaBomb.uc
index 5a00a73..6704d8b 100644
--- a/WFCode/Classes/WFPlasmaBomb.uc
+++ b/WFCode/Classes/WFPlasmaBomb.uc
@@ -21,6 +21,10 @@ var() bool bStartArmed;
 var bool bPlayerDied; // player died while arming the plasma
 var bool bArming;
 
+var bool bHoldPlayer;
+var vector HoldLocation;
+var EPhysics OldPhysics;
+
 var string ArmedEvent;
 
 simulated function PostBeginPlay()
@@ -84,6 +88,10 @@ function FreezePlayer()
 	P = WFS_PCSystemPlayer(Owner);
 	if (P != None)
 		P.FreezePlayer(ArmingDelay, 'SettingPlasma');
+	bHoldPlayer = true;
+	OldPhysics = Owner.Physics;
+	Owner.SetPhysics(PHYS_None);
+	HoldLocation = Location;
 }
 
 function UnfreezePlayer()
@@ -92,6 +100,8 @@ function UnfreezePlayer()
 	P = WFS_PCSystemPlayer(Owner);
 	if (P != None)
 		P.UnfreezePlayer('SettingPlasma');
+	bHoldPlayer = false;
+	Owner.SetPhysics(OldPhysics);
 }
 
 function Explode()
@@ -141,6 +151,14 @@ function Tick(float DeltaTime)
 {
 	if (!bEffectsCreated)
 		CreateEffects();
+
+	if ((Owner != None) && !bPlayerDied && bHoldPlayer)
+	{
+		Owner.Acceleration = vect(0,0,0);
+		Owner.Velocity = vect(0,0,0);
+		if (Owner.Location != Location)
+			Owner.SetLocation(Location);
+	}
 }
 
 function CreateEffects()
diff --git a/WFCode/Classes/WFPlasmaMedium.uc b/WFCode/Classes/WFPlasmaMedium.uc
index 25bb153..cfbd435 100644
--- a/WFCode/Classes/WFPlasmaMedium.uc
+++ b/WFCode/Classes/WFPlasmaMedium.uc
@@ -1,5 +1,7 @@
 class WFPlasmaMedium extends WFPlasmaBomb;
 
+// TODO: limit to 128*6 units range
+
 defaultproperties
 {
      ExplodeDelay=25
diff --git a/WFCode/Classes/WFPlasmaSmall.uc b/WFCode/Classes/WFPlasmaSmall.uc
index 3b23a41..fa3fd56 100644
--- a/WFCode/Classes/WFPlasmaSmall.uc
+++ b/WFCode/Classes/WFPlasmaSmall.uc
@@ -1,5 +1,7 @@
 class WFPlasmaSmall extends WFPlasmaBomb;
 
+// TODO: limit to 128*3 units range
+
 defaultproperties
 {
      ExplodeDelay=10
diff --git a/WFCode/Classes/WFPlasmaWave.uc b/WFCode/Classes/WFPlasmaWave.uc
index d00c61b..b4bd807 100644
--- a/WFCode/Classes/WFPlasmaWave.uc
+++ b/WFCode/Classes/WFPlasmaWave.uc
@@ -1,6 +1,21 @@
 class WFPlasmaWave extends ShockWave;
 
 var() name DamageType;
+var() float BaseDamage, DamageCoef, WaveScale;
+var() bool bUniformDamage;
+
+var string DamageList; // list of damaged actors so far "actor1,actor2,actor24,..etc"
+
+simulated function Tick( float DeltaTime )
+{
+	if ( Level.NetMode != NM_DedicatedServer )
+	{
+		ShockSize = WaveScale * (13 * (Default.LifeSpan - LifeSpan) + 3.5/(LifeSpan/Default.LifeSpan+0.05));
+		ScaleGlow = Lifespan;
+		AmbientGlow = ScaleGlow * 255;
+		DrawScale = ShockSize;
+	}
+}
 
 simulated function Timer()
 {
@@ -10,7 +25,7 @@ simulated function Timer()
 	local vector dir;
 	local float FFScale;
 
-	ShockSize =  13 * (Default.LifeSpan - LifeSpan) + 3.5/(LifeSpan/Default.LifeSpan+0.05);
+	ShockSize = WaveScale * (13 * (Default.LifeSpan - LifeSpan) + 3.5/(LifeSpan/Default.LifeSpan+0.05));
 	if ( Level.NetMode != NM_DedicatedServer )
 	{
 		if (ICount==4) spawn(class'WarExplosion2',,,Location);
@@ -18,7 +33,7 @@ simulated function Timer()
 
 		if ( Level.NetMode == NM_Client )
 		{
-			foreach VisibleCollidingActors( class 'Actor', Victims, ShockSize*29, Location )
+			foreach VisibleCollidingActors( class 'Actor', Victims, WaveScale*ShockSize*29, Location )
 				if ( Victims.Role == ROLE_Authority )
 				{
 					dir = Victims.Location - Location;
@@ -26,7 +41,9 @@ simulated function Timer()
 					dir = dir/dist +vect(0,0,0.3);
 					if ( (dist> OldShockDistance) || (dir dot Victims.Velocity <= 0))
 					{
-						MoScale = FMax(0, 1100 - 1.1 * Dist);
+						if (bUniformDamage)
+							MoScale = BaseDamage;
+						else MoScale = FMax(0, BaseDamage - DamageCoef * Dist);
 						Victims.Velocity = Victims.Velocity + dir * (MoScale + 20);
 						Victims.TakeDamage
 						(
@@ -42,39 +59,92 @@ simulated function Timer()
 		}
 	}
 
-	foreach VisibleCollidingActors( class 'Actor', Victims, ShockSize*29, Location )
+	foreach VisibleCollidingActors( class 'Actor', Victims, WaveScale*ShockSize*29, Location )
 	{
-		dir = Victims.Location - Location;
-		dist = FMax(1,VSize(dir));
-		dir = dir/dist + vect(0,0,0.3);
-		if (dist> OldShockDistance || (dir dot Victims.Velocity < 0))
+		if (CanDamageActor(Victims))
 		{
-			MoScale = FMax(0, 1100 - 1.1 * Dist);
-			if ( Victims.bIsPawn )
+			dir = Victims.Location - Location;
+			dist = FMax(1,VSize(dir));
+			dir = dir/dist + vect(0,0,0.3);
+			if (dist> OldShockDistance || (dir dot Victims.Velocity < 0))
 			{
-				if (Level.Game.bTeamGame && (Instigator != None) && (Instigator != Victims)
-					&& TeamGamePlus(Level.Game).IsOnTeam(pawn(Victims), Instigator.PlayerReplicationInfo.Team))
-						FFScale = TeamGamePlus(Level.Game).FriendlyFireScale;
-				else FFScale = 1.0;
+				if (bUniformDamage)
+					MoScale = BaseDamage;
+				else MoScale = FMax(0, BaseDamage - DamageCoef*Dist);
+				if ( Victims.bIsPawn )
+				{
+					if (Level.Game.bTeamGame && (Instigator != None) && (Instigator != Victims)
+						&& TeamGamePlus(Level.Game).IsOnTeam(pawn(Victims), Instigator.PlayerReplicationInfo.Team))
+							FFScale = TeamGamePlus(Level.Game).FriendlyFireScale;
+					else FFScale = 1.0;
 
-				Pawn(Victims).AddVelocity(dir * (MoScale + 20) * FFScale);
+					Pawn(Victims).AddVelocity(dir * (MoScale + 20) * FFScale);
+				}
+				else
+					Victims.Velocity = Victims.Velocity + dir * (MoScale + 20);
+				Victims.TakeDamage
+				(
+					MoScale,
+					Instigator,
+					Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,
+					(1000 * dir),
+					DamageType
+				);
+				if (damagelist == "")
+					Damagelist = string(victims.name);
+				else damagelist = damagelist $","$victims.name;
 			}
-			else
-				Victims.Velocity = Victims.Velocity + dir * (MoScale + 20);
-			Victims.TakeDamage
-			(
-				MoScale,
-				Instigator,
-				Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,
-				(1000 * dir),
-				DamageType
-			);
 		}
 	}
-	OldShockDistance = ShockSize*29;
+	OldShockDistance = ShockSize*29*WaveScale;
+}
+
+function bool CanDamageActor(actor Other)
+{
+	local string list, next;
+
+	if (Other == None)
+		return false;
+
+	list = damagelist;
+	next = GetNextDamageActor(list);
+	while (next != "")
+	{
+		if (next == string(other.name))
+			return false;
+		next = GetNextDamageActor(list);
+	}
+
+	return true;
+}
+
+function string GetNextDamageActor(out string actorlist)
+{
+	local string actorname;
+	local int pos;
+
+	pos = instr(actorlist, ",");
+
+	actorname = "";
+	if (pos >= 0)
+	{
+		actorname = Left(actorlist, pos);
+		actorlist = right(actorlist, len(actorlist) - (pos+1));
+	}
+	else if (actorlist != "")
+	{
+		actorname = actorlist;
+		actorlist = "";
+	}
+
+	return actorname;
 }
 
 defaultproperties
 {
      DamageType=WFPlasmaDeath
+     BaseDamage=1100.000000
+     DamageCoef=1.100000
+     WaveScale=1.000000
+     bUniformDamage=True
 }
diff --git a/WFCode/Classes/WFPlasmaWaveLarge.uc b/WFCode/Classes/WFPlasmaWaveLarge.uc
index 409d2d9..b0267bb 100644
--- a/WFCode/Classes/WFPlasmaWaveLarge.uc
+++ b/WFCode/Classes/WFPlasmaWaveLarge.uc
@@ -2,4 +2,6 @@ class WFPlasmaWaveLarge extends WFPlasmaWave;
 
 defaultproperties
 {
+     BaseDamage=500.000000
+     WaveScale=0.800000
 }
diff --git a/WFCode/Classes/WFPlasmaWaveMedium.uc b/WFCode/Classes/WFPlasmaWaveMedium.uc
index 1d376ce..b263e98 100644
--- a/WFCode/Classes/WFPlasmaWaveMedium.uc
+++ b/WFCode/Classes/WFPlasmaWaveMedium.uc
@@ -2,5 +2,7 @@ class WFPlasmaWaveMedium extends WFPlasmaWave;
 
 defaultproperties
 {
+     BaseDamage=250.000000
+     WaveScale=0.620000
      LifeSpan=1.000000
 }
diff --git a/WFCode/Classes/WFPlasmaWaveSmall.uc b/WFCode/Classes/WFPlasmaWaveSmall.uc
index c11ac0c..02c511e 100644
--- a/WFCode/Classes/WFPlasmaWaveSmall.uc
+++ b/WFCode/Classes/WFPlasmaWaveSmall.uc
@@ -2,5 +2,7 @@ class WFPlasmaWaveSmall extends WFPlasmaWave;
 
 defaultproperties
 {
-     LifeSpan=0.500000
+     BaseDamage=125.000000
+     WaveScale=0.620000
+     LifeSpan=1.000000
 }
diff --git a/WFCode/Classes/WFPlayer.uc b/WFCode/Classes/WFPlayer.uc
index 1ad1022..f5f345b 100644
--- a/WFCode/Classes/WFPlayer.uc
+++ b/WFCode/Classes/WFPlayer.uc
@@ -56,6 +56,19 @@ var WFRefereeInfo RefInfo; // set by the gameinfo
 var bool bMute; // player cannot send messages
 var int RefViewingTeam;
 
+// flood protection
+var bool bAdminLoginDisabled;
+var float FirstAdminLoginTime;
+var int NumAdminLogins;
+var float FirstRefLoginTime;
+var int NumRefLogins;
+var bool bRefLoginDisabled;
+
+// status rendering chain
+var WFPlayerStatus RenderExclusive, RenderChain;
+
+var bool bSuicided;
+
 replication
 {
 	reliable if (Role == ROLE_Authority)
@@ -72,7 +85,21 @@ replication
 		ClientLoadClassBindings, ClientReceiveEvent;
 
     reliable if (Role < ROLE_Authority)
-        RefLogin, RefLogout, Ref;
+        RefLogin, RefLogout, Ref, DebugInfo;
+}
+
+//=============================================================================
+// DEGBUG.
+//=============================================================================
+
+exec function DebugInfo()
+{
+	ClientMessage("State: "$GetStateName());
+	ClientMessage("Physics: "$GetPropertyText("Physics"));
+	ClientMessage("Collision: "$bCollideWorld$" "$bBlockPlayers$" "$bBlockActors);
+	ClientMessage("PRI Flags: bIsSpectator "$PlayerReplicationInfo.bIsSpectator$", bWaitingPlayer "$PlayerReplicationInfo.bWaitingPlayer);
+	ClientMessage("bFlagTouchDisabled: "$bFlagTouchDisabled);
+	ClientMessage("bHidden: "$bHidden$", Mesh: "$Mesh);
 }
 
 exec function GetState()
@@ -91,6 +118,95 @@ function DLog(coerce string S, optional float delay)
 	}
 }
 
+exec function Admin( string CommandLine )
+{
+	if (bAdmin && (InStr(Caps(CommandLine), "GET") != -1) && (InStr(CommandLine, "ADMINPASSWORD") != -1))
+		return; // surely a logged in admin would already know the admin password? :o)
+
+	super.Admin(CommandLine);
+}
+
+//=============================================================================
+// STATUS RENDERING CODE.
+//=============================================================================
+
+simulated function PostRender( canvas Canvas )
+{
+	RenderPlayerStatus(Canvas);
+	super.PostRender(Canvas);
+}
+
+simulated function RenderPlayerStatus(canvas Canvas)
+{
+	if ((RenderExclusive != None) && RenderExclusive.bExclusiveRender)
+	{
+		if (RenderExclusive.bDeleteMe)
+			RenderExclusive = None;
+		else
+		{
+			RenderExclusive.RenderStatus(Canvas);
+			return;
+		}
+	}
+
+	if (RenderChain != None)
+		RenderChain.RenderStatusChain(Canvas);
+}
+
+simulated function AddRenderedStatus(WFPlayerStatus NewStatus)
+{
+	if ((NewStatus.Role == ROLE_Authority) && (Level.NetMode == NM_Client))
+		return;
+
+	if (NewStatus.bExclusiveRender)
+	{
+		if ((RenderExclusive == None) || (RenderExclusive.bDeleteMe)
+			|| (RenderExclusive.RenderPriority < NewStatus.RenderPriority))
+		{
+			RenderExclusive = NewStatus;
+			return;
+		}
+	}
+
+	// add to the render list
+	if (RenderChain == None)
+	{
+		NewStatus.bRegistered = true;
+		RenderChain = NewStatus;
+	}
+	else if (RenderChain.RenderPriority > NewStatus.RenderPriority)
+	{
+		NewStatus.bRegistered = true;
+		NewStatus.NextStatus = RenderChain;
+		RenderChain = NewStatus;
+	}
+	else RenderChain.AddStatus(NewStatus);
+}
+
+simulated function RemoveRenderedStatus(WFPlayerStatus OldStatus)
+{
+	local WFPlayerStatus S;
+
+	if (RenderExclusive == OldStatus)
+	{
+		RenderExclusive = None;
+		OldStatus.bRegistered = false;
+	}
+
+	for (S=RenderChain; S!=None; S=S.NextStatus)
+	{
+		if (S.NextStatus == OldStatus)
+		{
+			S.NextStatus = OldStatus.NextStatus;
+			OldStatus.bRegistered = false;
+		}
+	}
+}
+
+//=============================================================================
+// EVENT CODE.
+//=============================================================================
+
 function ClientReceiveEvent(string EventID, name EventType)
 {
 	local string CmdType, CmdString;
@@ -141,12 +257,14 @@ function ServerProcessEvent(string EventName, name EventType, string CmdType, st
 	switch (caps(CmdType))
 	{
 		case "SAY":
-			// TODO: maybe allow for gloabal auto-message filtering later
-			Say(CmdString);
+			// TODO: maybe allow for global auto-message filtering later
+			if (CmdString != "")
+				Say(CmdString);
 			break;
 
 		case "TEAMSAY":
-			TeamSay(CmdString);
+			if (CmdString != "")
+				TeamSay(CmdString);
 			break;
 	}
 }
@@ -377,6 +495,9 @@ exec function Restore_NumKeys()
 event TeamMessage( PlayerReplicationInfo PRI, coerce string S, name Type, optional bool bBeep  )
 {
 	// TODO: add special handling for referee messages
+	if (S == "")
+		return;
+
 	if (Type == 'RefSay')
 		Type = 'Say';
 	else if (Type == 'RefTeamSay')
@@ -568,7 +689,8 @@ function ChangeTeam( int N )
 	local int OldTeam, OldScore, OldDeaths;
 
 	OldTeam = PlayerReplicationInfo.Team;
-	Level.Game.ChangeTeam(self, N);
+	if (N != PlayerReplicationInfo.Team)
+		Level.Game.ChangeTeam(self, N);
 	if ( Level.Game.bTeamGame && (PlayerReplicationInfo.Team != OldTeam) )
 	{
 		// save old score
@@ -662,8 +784,7 @@ exec function Team(string Team)
 		case "GOLD": TeamNum = 3; break;
 	}
 
-	if (TeamNum != 255)
-		ChangeTeam(TeamNum);
+	ChangeTeam(TeamNum);
 }
 
 exec function SetTeamPassword(coerce string Pwd)
@@ -732,6 +853,16 @@ exec function DropAmmo(optional int Amount)
 // WF Functions
 //=============================================================================
 
+function bool IsImmuneTo(class<WFPlayerStatus> StatusClass)
+{
+	local bool bIsImmune;
+
+	if (class<WFPlayerClassInfo>(PCInfo) != None)
+		bIsImmune = class<WFPlayerClassInfo>(PCInfo).static.IsImmuneTo(StatusClass);
+
+	return bIsImmune || (FindInventoryType(class'WFSpawnProtector') != None);
+}
+
 // set up a root window class that wont load the Mod menu
 function InitMenu(canvas Canvas)
 {
@@ -1010,6 +1141,9 @@ exec function Say( string Msg )
 {
 	local pawn P;
 
+	if (Msg == "")
+		return;
+
 	// forward message to RefInfo for processing
 	if (bReferee)
 	{
@@ -1043,6 +1177,9 @@ exec function Say( string Msg )
 
 exec function TeamSay(string Msg)
 {
+	if (Msg == "")
+		return;
+
 	// forward message to RefInfo for processing
 	if (bReferee)
 	{
@@ -1089,16 +1226,55 @@ event PlayerTimeOut()
     super.PlayerTimeOut();
 }
 
+// get status inventory to adjust view rotation
+function ViewShake(float DeltaTime)
+{
+	local inventory Item;
+	super.ViewShake(deltatime);
+
+	if (PlayerReplicationInfo==None || PlayerReplicationInfo.bIsSpectator || PlayerReplicationInfo.bWaitingPlayer)
+		return;
+
+	for (Item=Inventory; Item!=None; Item=Item.Inventory)
+		if (Item!=None && Item.IsA('WFPlayerStatus'))
+			WFPlayerStatus(Item).AdjustViewRotation(deltatime);
+}
+
+
 //=============================================================================
 // WF Player States
 //=============================================================================
 
-// referee state
-state RefereeMode extends PlayerSpectating
+exec function Suicide()
+{
+	bSuicided = true;
+	super.Suicide();
+}
+
+state Dying
 {
 	function BeginState()
 	{
+		super.BeginState();
+		if (bSuicided)
+		{
+			bSuicided = false;
+			SetTimer(5.0, false);
+			ClientMessage("5 second respawn penalty for suicide command.");
+		}
+	}
+}
+
+
+// referee state
+state RefereeMode extends PlayerSpectating
+{
+	exec function Suicide() { }
+
+	function BeginState()
+	{
 		bJoinedGame = false;
+		bFlagTouchDisabled = true;
 		PlayerReplicationInfo.bIsSpectator = true;
 		PlayerReplicationInfo.bWaitingPlayer = true;
 		//bShowScores = true;
@@ -1133,6 +1309,7 @@ state RefereeMode extends PlayerSpectating
 
 	function EndState()
 	{
+		bFlagTouchDisabled = false;
 		PlayerReplicationInfo.bIsSpectator = false;
 		PlayerReplicationInfo.bWaitingPlayer = false;
 		SetMesh();
@@ -1144,10 +1321,13 @@ state RefereeMode extends PlayerSpectating
 // login spectator state
 state PCSpectating
 {
+	exec function Suicide() { }
+
 	function BeginState()
 	{
 		Mesh = None;
 		bHidden = true;
+		bFlagTouchDisabled = true;
 		if ( PlayerReplicationInfo != None )
 		{
 			PlayerReplicationInfo.bIsSpectator = true;
@@ -1168,6 +1348,7 @@ state PCSpectating
 	function EndState()
 	{
 		bJoinedGame = true;
+		bFlagTouchDisabled = false;
 		CloseGameMenu();
 		super.EndState();
 	}
diff --git a/WFCode/Classes/WFPlayerClassInfo.uc b/WFCode/Classes/WFPlayerClassInfo.uc
index e13c3be..7dffc8a 100644
--- a/WFCode/Classes/WFPlayerClassInfo.uc
+++ b/WFCode/Classes/WFPlayerClassInfo.uc
@@ -37,10 +37,28 @@ static function bool IsImmuneTo(class<WFPlayerStatus> StatusClass)
 	return false;
 }
 
+static function bool PawnIsImmuneTo(pawn Other, class<WFPlayerStatus> StatusClass)
+{
+	local WFPlayer WFP;
+	local WFBot WFB;
+
+	WFP = WFPlayer(Other);
+	if (WFP != None)
+		return WFP.IsImmuneTo(StatusClass);
+	else
+	{
+		WFB = WFBot(Other);
+		if (WFB != None)
+			return WFB.IsImmuneTo(StatusClass);
+	}
+
+	return false;
+}
+
 static function PlayerTakeDamage(pawn Other, out int Damage, out Pawn instigatedBy,	out vector hitlocation, out vector momentum, out name damageType, out byte bIgnoreDamage)
 {
 	if (Other.IsInState('Frozen') && (Other.FindInventoryType(class'WFStatusFrozen') != None))
-		Damage = 0;
+		Damage *= 0.5;
 
 	if (Other.Level.Game.bTeamGame && (instigatedBy != None) && (instigatedBy != Other)
 		&& TeamGamePlus(Other.Level.Game).IsOnTeam(instigatedBy, Other.PlayerReplicationInfo.Team))
@@ -235,6 +253,6 @@ defaultproperties
      TranslocatorAmmoUsed=15
      bCanIdentify=True
      bAllowFeignDeath=False
-     ExtendedHUD=Class'WFCode.WFHUDInfo'
+     ExtendedHUD=Class'WFCode.WFCustomHUDInfo'
      ArmorManagerClass=Class'WFCode.WFArmor'
 }
diff --git a/WFCode/Classes/WFPlayerStatus.uc b/WFCode/Classes/WFPlayerStatus.uc
index 0e8182f..547068d 100644
--- a/WFCode/Classes/WFPlayerStatus.uc
+++ b/WFCode/Classes/WFPlayerStatus.uc
@@ -2,7 +2,7 @@
 // WFPlayerStatus.
 // Author: Ob1-Kenobi (ob1@planetunreal.com)
 //=============================================================================
-class WFPlayerStatus extends TournamentPickup
+class WFPlayerStatus extends WFPickup
 	abstract;
 
 var() float ScaleFactor; // scaling factor of the effect
@@ -224,8 +224,8 @@ simulated function RegisterStatus()
 	WFPlayerOwner = WFPlayer(Owner);
 	if (WFPlayerOwner == None) return;
 
-	if (bRenderStatus && (WFPlayerOwner.MyHUD != None))
-		WFHUD(WFPlayerOwner.MyHUD).AddRenderedStatus(self);
+	if (bRenderStatus)
+		WFPlayerOwner.AddRenderedStatus(self);
 }
 
 // Unregister this status
@@ -236,13 +236,16 @@ simulated function UnregisterStatus()
 	WFPlayerOwner = WFPlayer(Owner);
 	if (WFPlayerOwner == None) return;
 
-	if (bRenderStatus && (WFPlayerOwner.MyHUD != None))
-		WFHUD(WFPlayerOwner.MyHUD).RemoveRenderedStatus(self);
+	if (bRenderStatus)
+		WFPlayerOwner.RemoveRenderedStatus(self);
 }
 
 // Use this function instead of Tick()
 simulated function StatusTick(float DeltaTime);
 
+// If the status adjusts the players viewrotation in any way, it MUST do it here.
+simulated function AdjustViewRotation(float DeltaTime);
+
 // Called to add a status to the list
 simulated function AddStatus(WFPlayerStatus NewStatus)
 {
diff --git a/WFCode/Classes/WFPlazer.uc b/WFCode/Classes/WFPlazer.uc
index 6f7f56d..1cac0a6 100644
--- a/WFCode/Classes/WFPlazer.uc
+++ b/WFCode/Classes/WFPlazer.uc
@@ -22,6 +22,7 @@ function Fire( float Value )
 	}
 	if ( AmmoType.UseAmmo(1) )
 	{
+		NotifyFired();
 		GotoState ('NormalFire');
 		bPointing=True;
 		bCanClientFire = true;
@@ -41,6 +42,7 @@ function AltFire( float Value )
 	}
 	if (AmmoType.AmmoAmount > 1)
 	{
+		NotifyFired();
 		GotoState ('AltFireSwitchDown');
 		bPointing=True;
 		bCanClientFire = true;
@@ -418,8 +420,8 @@ defaultproperties
      PickupViewScale=0.500000
      ThirdPersonMesh=LodMesh'WFMedia.WFPlazer'
      ThirdPersonScale=0.500000
-     StatusIcon=Texture'WFMedia.Icons.IconLazer'
-     Icon=Texture'WFMedia.Icons.UseLazer'
+     StatusIcon=Texture'WFMedia.WeaponPlasmaLaser'
+     Icon=None
      Mesh=LodMesh'WFMedia.WFPlazer'
      bNoSmooth=False
      CollisionHeight=15.000000
diff --git a/WFCode/Classes/WFPyrotech.uc b/WFCode/Classes/WFPyrotech.uc
index 34e4622..92db25a 100644
--- a/WFCode/Classes/WFPyrotech.uc
+++ b/WFCode/Classes/WFPyrotech.uc
@@ -9,6 +9,21 @@ var() name FlameDamageType;
 var() float FlameMomentumTransfer;
 var() float FlameStatusScale;
 
+static function ModifyPlayer(pawn Other)
+{
+	local float SpeedScaling;
+
+	if (DeathMatchPlus(Other.Level.Game).bMegaSpeed)
+		SpeedScaling = 1.4;
+	else SpeedScaling = 1.0;
+
+	Other.GroundSpeed = (Other.default.GroundSpeed * SpeedScaling) * 1.1;
+	Other.WaterSpeed = (Other.default.WaterSpeed * SpeedScaling) * 1.1;
+	Other.AirSpeed = (Other.default.AirSpeed * SpeedScaling) * 1.1;
+	Other.AccelRate = (Other.default.AccelRate * SpeedScaling) * 1.1;
+	Other.Mass = Other.default.Mass * 0.9;
+}
+
 static function bool IsImmuneTo(class<WFPlayerStatus> StatusClass)
 {
 	if (StatusClass == class'WFStatusOnFire')
@@ -34,6 +49,7 @@ static function BlowUp(pawn Other, vector HitLocation)
 	local WFStatusOnFire s;
 	local bool bGiveStatus;
 	local class<WFPlayerClassInfo> PCI;
+	local WFPlayer WFP;
 
 	Other.HurtRadius(default.FlameDamage, default.FlameRadius, default.FlameDamageType, default.FlameMomentumTransfer, HitLocation);
 
@@ -43,8 +59,10 @@ static function BlowUp(pawn Other, vector HitLocation)
 		{
 			bGiveStatus = false;
 
-			PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
-			bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+			//WFP = WFPlayer(aPawn);
+			//PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(aPawn));
+			//bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusOnFire');
+			bGiveStatus = !class'WFPlayerClassInfo'.static.PawnIsImmuneTo(aPawn, class'WFStatusOnFire');
 
 			if (bGiveStatus && (aPawn.PlayerReplicationInfo.Team != Other.PlayerReplicationInfo.Team))
 			{
@@ -71,10 +89,9 @@ defaultproperties
      bNoEnforcer=True
      ClassName="Pyrotech"
      ClassNamePlural="Pyrotechs"
-     MeshInfo=Class'WFSystem.WFD_TMale1MeshInfo'
-     AltMeshInfo=Class'WFSystem.WFD_TMale1BotMeshInfo'
+     MeshInfo=Class'WFCode.WFPyrotechMeshInfo'
+     AltMeshInfo=Class'WFCode.WFPyrotechBotMeshInfo'
      DefaultInventory=Class'WFCode.WFPyrotechInv'
-     ExtendedHUD=Class'WFSystem.WFS_CTFHUDInfo'
      Armor=100
      ClassDescription="WFCode.WFClassHelpPyrotech"
      ClassSkinName="WFSkins.pyro"
diff --git a/WFCode/Classes/WFRDUAmmo.uc b/WFCode/Classes/WFRDUAmmo.uc
index 0418334..567322f 100644
--- a/WFCode/Classes/WFRDUAmmo.uc
+++ b/WFCode/Classes/WFRDUAmmo.uc
@@ -27,6 +27,8 @@ Begin:
 
 defaultproperties
 {
-     RechargeRate=5
+     RechargeRate=2
      bRecharge=True
+     AmmoAmount=35
+     MaxAmmo=35
 }
diff --git a/WFCode/Classes/WFRDUShieldEffect.uc b/WFCode/Classes/WFRDUShieldEffect.uc
index 2980b8a..2b99b95 100644
--- a/WFCode/Classes/WFRDUShieldEffect.uc
+++ b/WFCode/Classes/WFRDUShieldEffect.uc
@@ -8,11 +8,13 @@ function Touch(actor Other)
 
 simulated function Tick(float DeltaTime)
 {
-	local vector X, Y, Z;
+	local vector X, Y, Z, NewLoc;
 	if (Owner != None)
 	{
 		GetAxes(Owner.Rotation, X, Y, Z);
-		SetLocation(Owner.Location + X * ForwardOffset);
+		NewLoc = Owner.Location + X * ForwardOffset;
+		if (Location != NewLoc)
+			SetLocation(NewLoc);
 		SetRotation(Owner.Rotation);
 	}
 }
diff --git a/WFCode/Classes/WFRailGun.uc b/WFCode/Classes/WFRailGun.uc
index d9de56a..b83fadd 100644
--- a/WFCode/Classes/WFRailGun.uc
+++ b/WFCode/Classes/WFRailGun.uc
@@ -63,6 +63,7 @@ function AltFire( float Value )
 	}
 	if ( AmmoType.UseAmmo(1) )
 	{
+		NotifyFired();
 		GoToState('AltFiring');
 		bCanClientFire = true;
 		ClientAltFire(Value);
@@ -292,7 +293,7 @@ function ProcessTraceActor(Actor Other, Vector HitLocation, Vector HitNormal, Ve
 		PlayerOwner.ClientInstantFlash( -0.4, vect(450, 190, 650));
 
 	if ( (Other != self) && (Other != Owner) && (Other != None) )
-		Other.TakeDamage(RailBeamDamage*FClamp(ChargeSize/4.0, 0.25, 1.0), Pawn(Owner), HitLocation, (60000.0+40000.0*(ChargeSize/4.1))*X, MyDamageType);
+		Other.TakeDamage(RailBeamDamage*FClamp(ChargeSize/4.0, 0.25, 1.0), Pawn(Owner), HitLocation, (60000.0+40000.0*(ChargeSize/4.1))*X, AltDamageType);
 }
 
 function SpawnEffect(vector HitLocation, vector SmokeLocation)
@@ -382,6 +383,8 @@ defaultproperties
      FiringSpeed=1.000000
      FireOffset=(Y=-15.000000,Z=-13.000000)
      ProjectileClass=Class'WFCode.WFRailSlug'
+     MyDamageType=RailSlug
+     AltDamageType=Railed
      AIRating=0.500000
      RefireRate=0.900000
      AltRefireRate=0.900000
@@ -401,7 +404,7 @@ defaultproperties
      PickupViewMesh=LodMesh'Botpack.BRifle2Pick'
      ThirdPersonMesh=LodMesh'WFMedia.railthird'
      ThirdPersonScale=0.800000
-     StatusIcon=Texture'Botpack.Icons.UseBio'
+     StatusIcon=Texture'WFMedia.WeaponRailGun'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.UseBio'
      Mesh=LodMesh'WFMedia.railthird'
diff --git a/WFCode/Classes/WFRailSlug.uc b/WFCode/Classes/WFRailSlug.uc
index 5d33ddf..6fa7cd6 100644
--- a/WFCode/Classes/WFRailSlug.uc
+++ b/WFCode/Classes/WFRailSlug.uc
@@ -26,6 +26,7 @@ simulated function PostBeginPlay()
 
 defaultproperties
 {
+     MyDamageType=RailSlug
      AnimSequence=WingIn
      Skin=Texture'Botpack.Skins.JDomN0'
      Mesh=LodMesh'UnrealShare.GrenadeM'
diff --git a/WFCode/Classes/WFReconDefenseUnit.uc b/WFCode/Classes/WFReconDefenseUnit.uc
index 6ec9f3a..636ca19 100644
--- a/WFCode/Classes/WFReconDefenseUnit.uc
+++ b/WFCode/Classes/WFReconDefenseUnit.uc
@@ -20,14 +20,44 @@ var() int PlasmaEnergyRate; // energy used for shield per second
 var bool bPlasmaActive; // damage shield active
 var bool bForceActive; // force field active
 
+var float ShieldAngle;
+
 var effects MyEffect;
 
+var private float PiercingDamageScale;
+
+var float UpwardPush, ForwardPush;
+
 replication
 {
 	reliable if (Role == ROLE_Authority)
 		bPlasmaActive;
 }
 
+simulated event RenderTexture(ScriptedTexture Tex)
+{
+	local Color C;
+
+	C.R = 255;
+	C.G = 0;
+	C.B = 0;
+
+	Tex.DrawColoredText( 12, 16.5, string(AmmoType.AmmoAmount), Font'LEDFont2', C );
+}
+
+simulated event RenderOverlays( canvas Canvas )
+{
+	Texture'MiniAmmoled'.NotifyActor = Self;
+	Super.RenderOverlays(Canvas);
+	Texture'MiniAmmoled'.NotifyActor = None;
+}
+
+// call this to allow the next damage call to pass shield
+function ShieldPierced(float DamageScale)
+{
+	PiercingDamageScale = DamageScale;
+}
+
 function Fire( float Value )
 {
 	if (!WeaponActive())
@@ -37,6 +67,7 @@ function Fire( float Value )
 		GiveAmmo(pawn(Owner));
 	if (AmmoType.AmmoAmount > 0)
 	{
+		NotifyFired();
 		bPointing=True;
 		bCanClientFire = true;
 		ClientFire(Value);
@@ -131,6 +162,7 @@ function AltFire( float Value )
 	if (AmmoType.AmmoAmount <= 0)
 		return;
 
+	NotifyFired();
 	bPointing=True;
 	bCanClientFire = true;
 	Pawn(Owner).PlayRecoil(FiringSpeed);
@@ -197,12 +229,20 @@ function int ArmorAbsorbDamage(int Damage, name DamageType, vector HitLocation)
 	if( (DamageType!='None') && ((ProtectionType1==DamageType) || (ProtectionType2==DamageType)) )
 		return 0;
 
-	if (DamageType=='Drowned') Return Damage;
+	//if ((DamageType=='Drowned') || (DamageType=='Railed'))
+	//	Return Damage;
+	if (DamageType=='Drowned')
+		Return Damage;
 
 	if (bPlasmaActive && (HitLocation != vect(0,0,0)))
 	{
 		GetAxes(Owner.Rotation, X, Y, Z);
-		if ((Normal(HitLocation - Owner.Location) Dot X) > 0.0)
+		if (PiercingDamageScale > 0.0)
+		{
+			Scale = PiercingDamageScale;
+			PiercingDamageScale = 0.0; // reset piercing damage coef
+		}
+		else if ((Normal(HitLocation - Owner.Location) Dot X) > ShieldAngle)
 			Scale = AbsorbtionRatio;
 		else Scale = 1.0;
 
@@ -218,7 +258,7 @@ function ArmorImpactEffect(vector HitLocation)
 	if (bPlasmaActive && (HitLocation != vect(0,0,0)))
 	{
 		GetAxes(Owner.Rotation, X, Y, Z);
-		if ((Normal(HitLocation - Owner.Location) Dot X) > 0.0)
+		if ((Normal(HitLocation - Owner.Location) Dot X) > ShieldAngle)
 		{
 			if (FRand() < 0.5)
 				spawn(class'WFSparks',,, HitLocation, rotator(HitLocation-Owner.Location));
@@ -272,18 +312,29 @@ State DownWeapon
 function RadiusPush()
 {
 	local effects e;
+	local vector momentum, X, Y, Z;
+	local float scale;
+
 	if (Owner != None)
 	{
-		Owner.HurtRadius(FClamp(ForceDamage*ChargeSize, ForceDamage*0.5, MaxForceDamage), ForceRadius, 'ForceBlast', FClamp(ForceMag * ChargeSize, ForceMag, MaxForceMag), Owner.Location);
+		scale = FClamp(ChargeSize, 0.5, 4);
 
-		if (ChargeSize < 1.0)
-			e = spawn(class'WFRDUForceEffect1',,, Owner.Location, rotator(vect(0,0,1)));
-		else if (ChargeSize < 2.0)
-			e = spawn(class'WFRDUForceEffect2',,, Owner.Location, rotator(vect(0,0,1)));
-		else if (ChargeSize < 3.0)
-			e = spawn(class'WFRDUForceEffect3',,, Owner.Location, rotator(vect(0,0,1)));
+		// calculate upward push
+		momentum = vect(0,0,1)*UpwardPush*scale;
+
+		// add some directional momentum
+		//GetAxes(Pawn(Owner).ViewRotation, X, Y, Z);
+		//X.Z = 0.0; // only interested in left/right direction
+		//momentum += normal(X)*ForwardPush*scale;
+		//if ((owner.Physics == PHYS_Falling) && (Owner.Velocity.Z < 0.0))
+		//	Owner.Velocity.Z = 0.0;
+
+		Pawn(Owner).AddVelocity(momentum);
+
+		if (ChargeSize > 2.0)
+			e = spawn(class'WFRDUJumpEffect',,, Owner.Location - vect(0,0,0.9)*owner.CollisionHeight, rotator(vect(1,0,0)));
 		else
-			e = spawn(class'WFRDUForceEffect4',,, Owner.Location, rotator(vect(0,0,1)));
+			e = spawn(class'WFRDUJumpEffectSmall',,, Owner.Location - vect(0,0,0.9)*owner.CollisionHeight, rotator(vect(1,0,0)));
 
 		if (e != None)
 			e.PlaySound(sound'Expl04');
@@ -480,7 +531,9 @@ defaultproperties
      ForceDamage=10.000000
      MaxForceDamage=40.000000
      MaxChargeSize=4.000000
-     PlasmaEnergyRate=5
+     PlasmaEnergyRate=3
+     ShieldAngle=0.200000
+     UpwardPush=165.000000
      WeaponDescription="Classification: Recon Defense Unit"
      InstFog=(X=475.000000,Y=325.000000,Z=145.000000)
      AmmoName=Class'WFCode.WFRDUAmmo'
@@ -499,18 +552,19 @@ defaultproperties
      InventoryGroup=2
      PickupMessage="You got the Recon Defense Unit."
      ItemName="Recon Defense Unit"
-     PlayerViewOffset=(X=3.800000,Y=-1.600000,Z=-1.800000)
-     PlayerViewMesh=LodMesh'Botpack.ImpactHammer'
-     PickupViewMesh=LodMesh'Botpack.ImpPick'
-     ThirdPersonMesh=LodMesh'Botpack.ImpactHandm'
-     StatusIcon=Texture'Botpack.Icons.UseHammer'
+     PlayerViewOffset=(X=2.000000,Y=-1.500000,Z=-3.600000)
+     PlayerViewMesh=SkeletalMesh'WFMedia.ckrdufirst1Mesh'
+     PlayerViewScale=0.300000
+     ThirdPersonMesh=LodMesh'WFMedia.rduthird'
+     ThirdPersonScale=1.500000
+     StatusIcon=Texture'WFMedia.WeaponRDU'
      bIsAnArmor=True
+     AbsorptionPriority=255
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.UseHammer'
-     Texture=Texture'UnrealShare.Belt_fx.ShieldBelt.newgold'
      Mesh=LodMesh'Botpack.ImpPick'
      bNoSmooth=False
-     bMeshEnviroMap=True
+     MultiSkins(4)=ScriptedTexture'Botpack.Ammocount.miniammoled'
      SoundRadius=50
      SoundVolume=200
      Mass=15.000000
diff --git a/WFCode/Classes/WFReconHUDInfo.uc b/WFCode/Classes/WFReconHUDInfo.uc
index aac70c7..ac6138e 100644
--- a/WFCode/Classes/WFReconHUDInfo.uc
+++ b/WFCode/Classes/WFReconHUDInfo.uc
@@ -1,46 +1,65 @@
 //=============================================================================
 // WFReconHUDInfo.
 //=============================================================================
-class WFReconHUDInfo extends WFHUDInfo;
+class WFReconHUDInfo extends WFCustomHUDInfo;
 
 var() texture CustomIconTexture;
 
 // could make this a general use function and move to WFHUDInfo and WFITSHUDInfo
 simulated function DrawStatus(out byte bOverrideFunction, Canvas Canvas)
 {
-	local bool bHasDoll;
-	local float X, Y, StatScale;
-	local int IconValue;
+  local byte         Style;
+	local color        DigitBackground;
+  local texture      DigitTexure;
+  local int          ResourceAmount;
+  local WFCustomHUD MyOwnerHUD;
 
-	IconValue = GetIconValue();
+  MyOwnerHUD = WFCustomHUD( OwnerHUD );
 
-	if (!OwnerHUD.bHideStatus)
-	{
-		bHasDoll = !(Canvas.ClipX < 400);
-		if (bHasDoll)
-			StatScale = OwnerHUD.Scale * OwnerHUD.StatusScale;
-	}
+  // Preserve the current style
+  Style = Canvas.Style;
 
-	// draw the hud icon
-	Canvas.DrawColor = OwnerHUD.HUDColor;
-	if ( OwnerHUD.bHideStatus && OwnerHUD.bHideAllWeapons )
-	{
-		//X = 0.5 * Canvas.ClipX;
-		//Y = Canvas.ClipY - 128 * OwnerHUD.Scale;
-		X = Canvas.ClipX - 128 * OwnerHUD.Scale;
-		Y = 0;
-	}
-	else
-	{
-		X = Canvas.ClipX - 128 * StatScale - 140 * OwnerHUD.Scale;
-		Y = 128 * OwnerHUD.Scale; // Y=0 for armor, Y=64 for health
-	}
-	Canvas.SetPos(X,Y);
-	Canvas.DrawTile(CustomIconTexture, 128*OwnerHUD.Scale, 64*OwnerHUD.Scale, 0, 0, 128.0, 64.0);
+  Canvas.SetPos( Canvas.ClipX - ( 128 * MyOwnerHUD.MyStatusScale ),
+	               68 * MyOwnerHUD.MyStatusScale );
+
+  MyOwnerHUD.DrawPanel( Canvas,
+                        MyOwnerHUD.EPanel.PLeft,
+                        ERenderStyle.STY_Modulated,
+                        32, 32, MyOwnerHUD.HUDColor,
+												MyOwnerHUD.MyOpacity,
+                        MyOwnerHUD.MyStatusScale );
+  MyOwnerHUD.DrawPanel( Canvas,
+                        MyOwnerHUD.EPanel.PMiddle,
+	                      ERenderStyle.STY_Modulated,
+	                      96, 32, MyOwnerHUD.HUDColor,
+												MyOwnerHUD.MyOpacity,
+	                      MyOwnerHUD.MyStatusScale );
+
+	 Canvas.DrawColor = MyOwnerHUD.HUDColor;
+	 Canvas.Style = MyOwnerHUD.MySolidStyle;
+
+   Canvas.SetPos( Canvas.ClipX - ( 110 * MyOwnerHUD.MyStatusScale ),
+	                68 * MyOwnerHUD.MyStatusScale );
+   Canvas.DrawTile( Texture'ResourceIcon', 32 * MyOwnerHUD.MyStatusScale,
+	                  32 * MyOwnerHUD.MyStatusScale, 0, 0, 32.0, 32.0);
+
+   ResourceAmount = GetIconValue();
+   if( ResourceAmount < 0 )
+   {
+     ResourceAmount = 0;
+   }
+
+   Canvas.SetPos( Canvas.ClipX - ( 72 * MyOwnerHUD.MyStatusScale ),
+	                68 * MyOwnerHUD.MyStatusScale );
+   MyOwnerHUD.DrawDigits( Canvas,
+                          ResourceAmount,
+						              3,
+						              MyOwnerHUD.HUDColor,
+						              MyOwnerHUD.HUDBackgroundColor,
+						              MyOwnerHUD.MySolidStyle,
+						              ERenderStyle.STY_Translucent,
+													MyOwnerHUD.MyStatusScale);
 
-	// draw the value for the icon
-	Canvas.DrawColor = OwnerHUD.WhiteColor;
-	OwnerHUD.DrawBigNum(Canvas, Max(0,IconValue), X + 4 * OwnerHUD.Scale, Y + 16 * OwnerHUD.Scale, 1);
 }
 
 function int GetIconValue()
diff --git a/WFCode/Classes/WFRefereeInfo.uc b/WFCode/Classes/WFRefereeInfo.uc
index ba78ea2..2e8e6e5 100644
--- a/WFCode/Classes/WFRefereeInfo.uc
+++ b/WFCode/Classes/WFRefereeInfo.uc
@@ -124,16 +124,33 @@ function RefLogin(WFPlayer Other, coerce string LoginPwd)
 {
     local int Team;
     local TeamGamePlus TGP;
+    local WFPlayer WFP;
+ 	local float logintime;
+ 	local int MaxAttempts;
 
     if ((Other == None) || Other.bReferee || (RefPassword ~= ""))
 		return;
 
-    if ((MaxReferees > 0) && (NumReferees == MaxReferees))
+ 	WFP = Other; // urgh, should change this :o/
+ 	if ((WFP == None) || WFP.bRefLoginDisabled)
+ 		return;
+
+ 	if ((MaxReferees > 0) && (NumReferees == MaxReferees))
     {
         Other.ClientMessage("Maximum number of referees already logged in");
         return;
     }
 
+	MaxAttempts = WFGame(Level.Game).MaxLoginAttempts;
+
+ 	if (WFP.NumRefLogins == 0)
+ 	{
+ 		WFP.NumRefLogins++;
+ 		WFP.FirstRefLoginTime = Level.TimeSeconds;
+ 	}
+ 	else
+ 		WFP.NumRefLogins++;
+
     // check password
     if (LoginPwd ~= RefPassword)
     {
@@ -161,7 +178,18 @@ function RefLogin(WFPlayer Other, coerce string LoginPwd)
         BroadcastMessage(Other.PlayerReplicationInfo.PlayerName$" became a referee");
 
         NumReferees++;
+
+ 		WFP.NumRefLogins = 0;
+ 		WFP.FirstRefLoginTime = 0.0;
     }
+	else if (WFP.NumRefLogins > MaxAttempts)
+	{
+ 		// check to see if player is flooding to try to gain the password
+		WFP.bRefLoginDisabled = true;
+		WFP.NumRefLogins = 0;
+		WFP.FirstRefLoginTime = 0.0;
+		Log("INFO: REFLOGIN: "$WFP.PlayerReplicationInfo.PlayerName$" (IP: "$WFP.GetPlayerNetworkAddress()$") failed to log in within "$MaxAttempts$" attempts, REFEREE login disabled for this player");
+	}
 }
 
 function ClearPCI(WFPlayer Other)
diff --git a/WFCode/Classes/WFRoboticHand.uc b/WFCode/Classes/WFRoboticHand.uc
index bcb64f1..2e8f1e7 100644
--- a/WFCode/Classes/WFRoboticHand.uc
+++ b/WFCode/Classes/WFRoboticHand.uc
@@ -9,6 +9,9 @@ var float MaxScale;
 var float ScaleRate;
 var float RecoilSpeed;
 
+var int BaseAmount;
+var int RandomAmount;
+
 function float RateSelf( out int bUseAltMode )
 {
 	local float EnemyDist;
@@ -91,6 +94,7 @@ function Fire( float Value )
 	if (!WeaponActive())
 		return;
 
+	NotifyFired();
 	bPointing=True;
 	bCanClientFire = true;
 	ClientFire(Value);
@@ -103,6 +107,7 @@ function AltFire( float Value )
 	if (!WeaponActive())
 		return;
 
+	NotifyFired();
 	bPointing=True;
 	bCanClientFire = true;
 	Pawn(Owner).PlayRecoil(FiringSpeed);
@@ -352,7 +357,7 @@ function GiveConcussionTo(pawn Other)
 	local WFPlayerStatus s;
 
 	PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
-	if ( ((PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusConcussed'))
+	if ( (!class'WFPlayerClassInfo'.static.PawnIsImmuneTo(Other, class'WFStatusConcussed'))
 		&& (Other.PlayerReplicationInfo.Team != pawn(Owner).PlayerReplicationInfo.Team))
 	{
 		s = spawn(class'WFStatusConcussed',,, Other.Location);
@@ -424,14 +429,12 @@ function ProcessAltTraceHit(Actor Other, Vector HitLocation, Vector HitNormal, V
 
 function RepairArmor(inventory Item)
 {
+	local int amount;
+	amount = (BaseAmount + Rand(RandomAmount));
 	if (Item.IsA('WFS_PCSArmor'))
-	{
-		Item.Charge = Min(Item.Charge + (10 + Rand(10)), WFS_PCSArmor(Item).MaxCharge);
-		if (Item.IsA('WFArmor'))
-			WFArmor(Item).UpdateCharge();
-	}
+		WFS_PCSArmor(Item).AddArmor(amount);
 	else
-		Item.Charge = Min(Item.Charge + (10 + Rand(10)), Item.default.Charge);
+		Item.Charge = Min(Item.Charge + amount, Item.default.Charge);
 }
 
 function bool CanRepairArmor(inventory Item)
@@ -467,6 +470,8 @@ defaultproperties
      MaxScale=1.000000
      ScaleRate=0.750000
      RecoilSpeed=1.000000
+     BaseAmount=10
+     RandomAmount=10
      WeaponDescription="Classification: Melee Piston"
      InstFog=(X=475.000000,Y=325.000000,Z=145.000000)
      bMeleeWeapon=True
@@ -486,7 +491,7 @@ defaultproperties
      PickupViewMesh=LodMesh'UnrealShare.TazerProja'
      ThirdPersonMesh=LodMesh'UnrealShare.TazerProja'
      ThirdPersonScale=0.000000
-     StatusIcon=Texture'Botpack.Icons.UseHammer'
+     StatusIcon=Texture'WFMedia.WeaponRobotHand'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.UseHammer'
      Mesh=LodMesh'Botpack.ImpPick'
diff --git a/WFCode/Classes/WFRocket.uc b/WFCode/Classes/WFRocket.uc
index fc553f1..bd39ea9 100644
--- a/WFCode/Classes/WFRocket.uc
+++ b/WFCode/Classes/WFRocket.uc
@@ -1,5 +1,7 @@
 class WFRocket extends RocketMk2;
 
+var() float BlastRadius;
+
 simulated function PostBeginPlay()
 {
 	Trail = Spawn(class'WFRocketTrail',self);
@@ -20,11 +22,21 @@ simulated function PostBeginPlay()
 	SetTimer(SmokeRate, true);
 }
 
+auto state Flying
+{
+	function BlowUp(vector HitLocation)
+	{
+		HurtRadius(Damage,BlastRadius, MyDamageType, MomentumTransfer, HitLocation );
+		MakeNoise(1.0);
+	}
+}
+
 defaultproperties
 {
+     BlastRadius=165.000000
      speed=1125.000000
      MaxSpeed=2000.000000
-     Damage=80.000000
+     Damage=90.000000
      Mesh=LodMesh'WFMedia.WF_Rocket'
      DrawScale=1.000000
 }
diff --git a/WFCode/Classes/WFRocketLauncher.uc b/WFCode/Classes/WFRocketLauncher.uc
index a9ed873..fbd18dc 100644
--- a/WFCode/Classes/WFRocketLauncher.uc
+++ b/WFCode/Classes/WFRocketLauncher.uc
@@ -50,6 +50,7 @@ function Fire( float Value )
 		bPointing=True;
 		bCanClientFire = true;
 		ClientFire(Value);
+		NotifyFired();
 		if ( bRapidFire || (FiringSpeed > 0) )
 			Pawn(Owner).PlayRecoil(FiringSpeed);
 		FireRocket(true);
@@ -74,6 +75,7 @@ function AltFire( float Value )
 		bPointing=True;
 		bCanClientFire = true;
 		ClientAltFire(Value);
+		NotifyFired();
 		if ( bRapidFire || (FiringSpeed > 0) )
 			Pawn(Owner).PlayRecoil(FiringSpeed);
 		FireRocket();
@@ -365,7 +367,7 @@ defaultproperties
      BobDamping=0.975000
      PickupViewMesh=LodMesh'Botpack.Eight2Pick'
      ThirdPersonMesh=LodMesh'WFMedia.rlthird'
-     StatusIcon=Texture'Botpack.Icons.Use8ball'
+     StatusIcon=Texture'WFMedia.WeaponRocketLaucher'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      Icon=Texture'Botpack.Icons.Use8ball'
      Mesh=LodMesh'Botpack.Eight2Pick'
diff --git a/WFCode/Classes/WFScoreBoard.uc b/WFCode/Classes/WFScoreBoard.uc
index 32337c2..d2322dd 100644
--- a/WFCode/Classes/WFScoreBoard.uc
+++ b/WFCode/Classes/WFScoreBoard.uc
@@ -7,6 +7,36 @@
 //=============================================================================
 class WFScoreBoard extends UnrealCTFScoreBoard;
 
+function DrawHeader( canvas Canvas )
+{
+  local GameReplicationInfo GRI;
+  local float XL, YL;
+  local font CanvasFont;
+
+  Canvas.DrawColor = WhiteColor;
+  GRI = PlayerPawn(Owner).GameReplicationInfo;
+
+  Canvas.Font = Canvas.LargeFont;
+
+  Canvas.bCenter = True;
+  Canvas.StrLen("Test", XL, YL);
+  ScoreStart = 58.0/768.0 * Canvas.ClipY;
+  CanvasFont = Canvas.Font;
+  if ( GRI.GameEndedComments != "" )
+  {
+    Canvas.DrawColor = GoldColor;
+    Canvas.SetPos(0, ScoreStart);
+    Canvas.DrawText(GRI.GameEndedComments, True);
+  }
+  else
+  {
+    Canvas.SetPos(0, ScoreStart);
+    DrawVictoryConditions(Canvas);
+  }
+  Canvas.bCenter = False;
+  Canvas.Font = CanvasFont;
+}
+
 function ShowScores( canvas Canvas )
 {
 	local PlayerReplicationInfo PRI;
diff --git a/WFCode/Classes/WFSniper.uc b/WFCode/Classes/WFSniper.uc
index 0293a76..180f7b6 100644
--- a/WFCode/Classes/WFSniper.uc
+++ b/WFCode/Classes/WFSniper.uc
@@ -12,7 +12,7 @@ defaultproperties
      MeshInfo=Class'WFSystem.WFD_TMale2MeshInfo'
      AltMeshInfo=Class'WFSystem.WFD_TMale2BotMeshInfo'
      DefaultInventory=Class'WFCode.WFSniperInv'
-     Armor=25
+     Armor=50
      ClassDescription="WFCode.WFClassHelpSniper"
      ClassSkinName="WFSkins.snip"
      ClassFaceName="WFSkins.bevis"
diff --git a/WFCode/Classes/WFSniperInv.uc b/WFCode/Classes/WFSniperInv.uc
index 682fc3c..3f48941 100644
--- a/WFCode/Classes/WFSniperInv.uc
+++ b/WFCode/Classes/WFSniperInv.uc
@@ -11,7 +11,7 @@ static function ModifyWeapon(weapon NewWeapon)
 	//if ((newWeapon.class == class'WFAutoRifle') && (newWeapon.AmmoType != none))
 	//	newWeapon.AmmoType.AddAmmo(25);
 
-	if (NewWeapon.class == class'WFSniperRifle')
+	if (NewWeapon.class == class'WFSniperRifleCSHP')
 		NewWeapon.AmmoType.AddAmmo(10);
 }
 
@@ -24,6 +24,6 @@ static function ModifyPickup(pickup NewPickup)
 defaultproperties
 {
      Weapons(0)=Class'WFCode.WFEnforcer'
-     Weapons(1)=Class'WFCode.WFSniperRifle'
+     Weapons(1)=Class'WFCode.WFSniperRifleCSHP'
      Pickups(0)=Class'WFCode.WFGrenFrag'
 }
diff --git a/WFCode/Classes/WFSniperRifle.uc b/WFCode/Classes/WFSniperRifle.uc
index 80e2b5c..da653d6 100644
--- a/WFCode/Classes/WFSniperRifle.uc
+++ b/WFCode/Classes/WFSniperRifle.uc
@@ -208,7 +208,7 @@ function GiveLegshot(pawn Other)
 		return;
 
 	PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
-	bGiveStatus = (PCI == None) || !PCI.static.IsImmuneTo(class'WFStatusLegDamage');
+	bGiveStatus = !class'WFPlayerClassInfo'.static.PawnIsImmuneTo(Other, class'WFStatusLegDamage');
 	if (bGiveStatus)
 	{
 		s = WFStatusLegDamage(Other.FindInventoryType(class'WFStatusLegDamage'));
@@ -319,6 +319,8 @@ state Zooming
 
 	simulated function BeginState()
 	{
+		if (Role == ROLE_Authority)
+			Owner.bAlwaysRelevant = true;
 		if ( Owner.IsA('PlayerPawn') )
 		{
 			if ( PlayerPawn(Owner).Player.IsA('ViewPort') )
@@ -332,6 +334,12 @@ state Zooming
 			Global.Fire(0);
 		}
 	}
+
+	function EndState()
+	{
+		if (Role == ROLE_Authority)
+			Owner.bAlwaysRelevant = false;
+	}
 }
 
 ///////////////////////////////////////////////////////////
@@ -341,6 +349,12 @@ simulated function PlayIdleAnim()
 		PlayAnim('Still',1.0, 0.05);
 }
 
+function Destroyed()
+{
+	Owner.bAlwaysRelevant = false;
+	super.Destroyed();
+}
+
 defaultproperties
 {
      FireAnims(0)=Fire
@@ -355,7 +369,7 @@ defaultproperties
      bAltInstantHit=True
      FiringSpeed=1.800000
      FireOffset=(Y=-5.000000,Z=-2.000000)
-     MyDamageType=shot
+     MyDamageType=RifleShot
      AltDamageType=Decapitated
      shakemag=400.000000
      shaketime=0.150000
@@ -385,7 +399,7 @@ defaultproperties
      BobDamping=0.975000
      PickupViewMesh=LodMesh'Botpack.RiflePick'
      ThirdPersonMesh=LodMesh'Botpack.RifleHand'
-     StatusIcon=Texture'Botpack.Icons.UseRifle'
+     StatusIcon=Texture'WFMedia.WeaponSniperRifle'
      bMuzzleFlashParticles=True
      MuzzleFlashStyle=STY_Translucent
      MuzzleFlashMesh=LodMesh'Botpack.muzzsr3'
diff --git a/WFCode/Classes/WFStatusConcussed.uc b/WFCode/Classes/WFStatusConcussed.uc
index 89a9e06..824e8ba 100644
--- a/WFCode/Classes/WFStatusConcussed.uc
+++ b/WFCode/Classes/WFStatusConcussed.uc
@@ -116,7 +116,7 @@ function Timer()
 	UsedUp();
 }
 
-simulated function StatusTick( float DeltaTime )
+simulated function AdjustViewRotation( float DeltaTime )
 {
 	if (bInitialised)
 		SwayView(DeltaTime);
diff --git a/WFCode/Classes/WFStatusInfected.uc b/WFCode/Classes/WFStatusInfected.uc
index 7727342..1ec0bd6 100644
--- a/WFCode/Classes/WFStatusInfected.uc
+++ b/WFCode/Classes/WFStatusInfected.uc
@@ -98,8 +98,7 @@ function InfectPlayer(pawn Other)
 		return;
 
 	// don't infect players that are immune to this status type
-	PCI = class<WFPlayerClassInfo>(class'WFS_PlayerClassInfo'.static.GetPCIFor(Other));
-	if ((PCI != None) && PCI.static.IsImmuneTo(Class))
+	if (class'WFPlayerClassInfo'.static.PawnIsImmuneTo(Other, Class))
 		return;
 
 	// don't infect players that already have it
@@ -128,7 +127,7 @@ function InfectTouchingPlayers()
 
 defaultproperties
 {
-     InfectionTime=80
+     InfectionTime=30
      DamageAmount=5
      DamageType=InfectedStatus
      DamageTime=2
diff --git a/WFCode/Classes/WFStatusKami.uc b/WFCode/Classes/WFStatusKami.uc
index 5e48773..a8abebb 100644
--- a/WFCode/Classes/WFStatusKami.uc
+++ b/WFCode/Classes/WFStatusKami.uc
@@ -59,10 +59,10 @@ state Exploding
 		A = WFArmor(pawn(owner).FindInventoryType(class'WFArmor'));
 		if (A != None)
 			RangeScale = A.Charge/A.MaxCharge;
-		Spawn(class'WFKamiWave',,, PawnOwner.Location);
 		PawnOwner.Health = -1000;
 		PawnOwner.Died(PawnOwner, 'KamikazeStatus', PawnOwner.Location);
-		PawnOwner.HurtRadius(1000, 650.0 - 350.0*RangeScale, 'KamikazeStatus', 100000, PawnOwner.Location);
+		//PawnOwner.HurtRadius(1000, Max(300, 650.0 - 350.0*RangeScale), 'KamikazeStatus', 100000, PawnOwner.Location);
+		Spawn(class'WFKamiWave',,, PawnOwner.Location);
 	}
 }
 
diff --git a/WFCode/Classes/WFStatusLegDamage.uc b/WFCode/Classes/WFStatusLegDamage.uc
index ff709ee..89ae53a 100644
--- a/WFCode/Classes/WFStatusLegDamage.uc
+++ b/WFCode/Classes/WFStatusLegDamage.uc
@@ -74,4 +74,5 @@ defaultproperties
      StatusID=7
      ExpireMessage="Leg damage healed."
      PickupMessage="Leg damage - Movement slowed by 50%!"
+     LifeSpan=10.000000
 }
diff --git a/WFCode/Classes/WFSupplyPack.uc b/WFCode/Classes/WFSupplyPack.uc
index fae49fa..666b808 100644
--- a/WFCode/Classes/WFSupplyPack.uc
+++ b/WFCode/Classes/WFSupplyPack.uc
@@ -178,6 +178,7 @@ defaultproperties
      AmmoTypes(8)=Class'Botpack.WarHeadAmmo'
      AmmoTypes(9)=Class'WFCode.WFASAmmo'
      AmmoTypes(10)=Class'WFCode.WFChainCannonAmmo'
+     AmmoTypes(11)=Class'WFCode.WFFlameThrowerAmmo'
      AmmoAmounts(0)=50.000000
      AmmoAmounts(1)=35.000000
      AmmoAmounts(2)=25.000000
@@ -189,6 +190,7 @@ defaultproperties
      AmmoAmounts(8)=1.000000
      AmmoAmounts(9)=5.000000
      AmmoAmounts(10)=50.000000
+     AmmoAmounts(11)=25.000000
      ResourceAmount=50.000000
      ArmorAmount=100.000000
      bAddGrenadeAmmo=True
diff --git a/WFCode/Classes/WFTaser.uc b/WFCode/Classes/WFTaser.uc
index 9432fe4..3d3f548 100644
--- a/WFCode/Classes/WFTaser.uc
+++ b/WFCode/Classes/WFTaser.uc
@@ -17,12 +17,6 @@ var bool bWeaponDisguised;
 var class<Weapon> DisguiseClass;
 var WFDisguise MainDisguise;
 
-/*replication
-{
-	reliable if (bNetOwner && (Role == ROLE_Authority))
-		bWeaponDisguised, DisguiseClass;
-}*/
-
 function GiveTo(pawn Other)
 {
 	super.GiveTo(Other);
@@ -34,23 +28,14 @@ simulated function PlayFiring()
 {
 	PlayAnim( 'Fire1', 0.9, 0.05 );
 	PlayOwnedSound(FireSound, SLOT_None, 1.7*Pawn(Owner).SoundDampening);
-	// NOTE: animation *must* finish, ie. use PlayAnim, or TweenAnim
 }
 
 simulated function PlayAltFiring()
 {
-	// play owned sound
-	//PlayOwnedSound(AltFireSound, SLOT_Misc, 1.7*Pawn(Owner).SoundDampening);
-	// play anim
-
-	//PlayAnim( 'Fire2', 0.9, 0.05 );
-
-	// NOTE: animation *must* finish, ie. use PlayAnim, or TweenAnim
 }
 
 simulated function PlayRecharging()
 {
-	// NOTE: animation *must* finish, ie. use PlayAnim, or TweenAnim
 	PlayOwnedSound(RechargeSound, SLOT_None, 1.7*Pawn(Owner).SoundDampening);
 
 	PlayAnim( 'recharge', 0.2, 0.05 );
@@ -77,6 +62,7 @@ function Fire( float Value )
 		MainDisguise.RemoveDisguise();
 	}
 
+	NotifyFired();
 	GotoState('NormalFire');
 	bPointing=True;
 	Pawn(Owner).PlayRecoil(0.25);
@@ -411,7 +397,7 @@ defaultproperties
      PickupViewMesh=LodMesh'WFMedia.taserpick'
      ThirdPersonMesh=LodMesh'WFMedia.taser3rd'
      ThirdPersonScale=0.900000
-     StatusIcon=Texture'Botpack.Icons.UseHammer'
+     StatusIcon=Texture'WFMedia.WeaponTazer'
      PickupSound=Sound'UnrealShare.Pickups.WeaponPickup'
      ActivateSound=Sound'UnrealI.Pickups.dampndea'
      DeActivateSound=Sound'UnrealI.Pickups.DampSnd'
diff --git a/WFCode/Classes/WFTeslaCoil.uc b/WFCode/Classes/WFTeslaCoil.uc
index b6359aa..acdc61b 100644
--- a/WFCode/Classes/WFTeslaCoil.uc
+++ b/WFCode/Classes/WFTeslaCoil.uc
@@ -165,6 +165,7 @@ function Fire( float Value )
 	}
 	if (AmmoType.UseAmmo(PriAmmoUsed))
 	{
+		NotifyFired();
 		GotoState('NormalFire');
 		bCanClientFire = true;
 		bPointing=True;
@@ -193,6 +194,7 @@ function AltFire( float Value )
 	}
 	if (AmmoType.UseAmmo(AltAmmoUsed))
 	{
+		NotifyFired();
 		GotoState('AltFiring');
 		bCanClientFire = true;
 		bPointing=True;
@@ -510,7 +512,7 @@ defaultproperties
      PickupViewMesh=LodMesh'Botpack.PulsePickup'
      ThirdPersonMesh=LodMesh'Botpack.PulseGun3rd'
      ThirdPersonScale=0.400000
-     StatusIcon=Texture'Botpack.Icons.UsePulse'
+     StatusIcon=Texture'WFMedia.WeaponTesla'
      bMuzzleFlashParticles=True
      MuzzleFlashStyle=STY_Translucent
      MuzzleFlashMesh=LodMesh'Botpack.muzzPF3'
diff --git a/WFCode/Classes/WFThrustPack.uc b/WFCode/Classes/WFThrustPack.uc
index 648e987..fd53a52 100644
--- a/WFCode/Classes/WFThrustPack.uc
+++ b/WFCode/Classes/WFThrustPack.uc
@@ -1,4 +1,4 @@
-class WFThrustPack extends TournamentPickup;
+class WFThrustPack extends WFPickup;
 
 var() float ThrustSpeed;
 var() float ThrustLift;
@@ -121,7 +121,7 @@ state Thrusting
 	{
 		ThrustTimeLeft--;
 		if (ThrustTimeLeft <= 0)
-			GotoState('Idle2');
+			GotoState('WaitForLanding');
 	}
 
 	function Use(pawn User) { }
@@ -166,10 +166,32 @@ state Thrusting
 			if (status != None)
 				WFStatusLegDamage(status).SetPlayerMovement();
 		}
-		EnableFlagTouch();
 	}
 }
 
+state WaitForLanding
+{
+	function Tick(float DeltaTime)
+	{
+		super.Tick(deltaTime);
+		if (Owner.Physics != PHYS_Falling)
+		{
+			// landed
+			EnableFlagTouch();
+			CheckTouching();
+			GotoState('Idle2');
+		}
+	}
+}
+
+function CheckTouching()
+{
+	local int i;
+	for(i=0; i<4; i++)
+		if (Touching[i] != None)
+			Touching[i].Touch(Owner);
+}
+
 function DisableFlagTouch()
 {
 	local pawn Other;
diff --git a/WFCode/Classes/WFTranslocator.uc b/WFCode/Classes/WFTranslocator.uc
index 51351d1..51a0ac1 100644
--- a/WFCode/Classes/WFTranslocator.uc
+++ b/WFCode/Classes/WFTranslocator.uc
@@ -210,4 +210,5 @@ defaultproperties
      MessageDelay=1.000000
      AmmoName=Class'WFCode.WFTranslocatorAmmo'
      PickupAmmoCount=50
+     StatusIcon=Texture'WFMedia.WeaponTranslocator'
 }
diff --git a/WFCode/Classes/WFWeapon.uc b/WFCode/Classes/WFWeapon.uc
index 5b46dc3..9f83b67 100644
--- a/WFCode/Classes/WFWeapon.uc
+++ b/WFCode/Classes/WFWeapon.uc
@@ -14,6 +14,17 @@ function function PostBeginPlay()
 // serverside weapon event
 function WeaponEvent(name EventType);
 
+function DropFrom(vector StartLocation)
+{
+	if (!bCanThrow)
+	{
+		Destroy();
+		return;
+	}
+
+	super.DropFrom(StartLocation);
+}
+
 function bool WeaponActive()
 {
 	if ((Owner != None) && Owner.IsA('Bot'))
@@ -88,6 +99,7 @@ function Fire( float Value )
 	}
 	if ( AmmoType.UseAmmo(1) )
 	{
+		NotifyFired();
 		GotoState('NormalFire');
 		bPointing=True;
 		bCanClientFire = true;
@@ -101,6 +113,27 @@ function Fire( float Value )
 	}
 }
 
+function NotifyFired()
+{
+	local inventory Item;
+
+	for (Item = pawn(Owner).Inventory; Item!=None; Item = Item.Inventory)
+	{
+		if (WFPickup(Item) != None)
+			WFPickup(Item).WeaponFired(self);
+		/*
+		if (WFCloaker(Item) != None)
+			WFCloaker(Item).WeaponFired(self);
+
+		if (WFDisguise(Item) != None)
+			WFDisguise(Item).WeaponFired(self);
+
+		if (WFSawnProtector(Item) != None)
+			WFDisguise(Item).WeaponFired(self);
+		*/
+	}
+}
+
 function AltFire( float Value )
 {
 	if (!WeaponActive())
@@ -113,6 +146,7 @@ function AltFire( float Value )
 	}
 	if (AmmoType.UseAmmo(1))
 	{
+		NotifyFired();
 		GotoState('AltFiring');
 		bPointing=True;
 		bCanClientFire = true;
diff --git a/WFCode/Classes/WF_BotPRI.uc b/WFCode/Classes/WF_BotPRI.uc
index 0d1229b..7928fc7 100644
--- a/WFCode/Classes/WF_BotPRI.uc
+++ b/WFCode/Classes/WF_BotPRI.uc
@@ -21,10 +21,12 @@ const PS_Disguised	= 128;	// the player is currently disguised
 var int StatusFlags; // the bots current status
 var string ClassName; // string name of player class
 
+var int MiscScoreArray[8]; // miscellaneous scoring vars
+
 replication
 {
 	reliable if (Role == ROLE_Authority)
-		StatusFlags, ClassName;
+		StatusFlags, ClassName, MiscScoreArray;
 }
 
 defaultproperties
diff --git a/WFCode/Classes/WF_PRI.uc b/WFCode/Classes/WF_PRI.uc
index 88d5dd6..bf0fbfd 100644
--- a/WFCode/Classes/WF_PRI.uc
+++ b/WFCode/Classes/WF_PRI.uc
@@ -22,10 +22,12 @@ const PS_Disguised	= 128;	// the player is currently disguised
 var int StatusFlags; // the players current status
 var string ClassName; // string name of player class
 
+var int MiscScoreArray[8]; // miscellaneous scoring vars
+
 replication
 {
 	reliable if (Role == ROLE_Authority)
-		StatusFlags, ClassName;
+		StatusFlags, ClassName, MiscScoreArray;
 }
 
 defaultproperties
diff --git a/WFCode/Classes/WFminigun2.uc b/WFCode/Classes/WFminigun2.uc
index 74e2a03..cbe4521 100644
--- a/WFCode/Classes/WFminigun2.uc
+++ b/WFCode/Classes/WFminigun2.uc
@@ -193,6 +193,7 @@ function Fire( float Value )
 	}
 	if ( AmmoType.UseAmmo(1) )
 	{
+		NotifyFired();
 		SoundVolume = 255*Pawn(Owner).SoundDampening;
 		Pawn(Owner).PlayRecoil(FiringSpeed);
 		bCanClientFire = true;
@@ -220,6 +221,7 @@ function AltFire( float Value )
 		bPointing=True;
 		bCanClientFire = true;
 		ShotAccuracy = 0.95;
+		NotifyFired();
 		Pawn(Owner).PlayRecoil(FiringSpeed);
 		SoundVolume = 255*Pawn(Owner).SoundDampening;
 		ClientAltFire(value);
@@ -559,10 +561,10 @@ defaultproperties
      AIRating=0.730000
      RefireRate=0.990000
      AltRefireRate=0.990000
-     FireSound=Sound'Botpack.minigun2.M2RegFire'
-     AltFireSound=Sound'Botpack.minigun2.M2AltFire'
+     FireSound=Sound'Botpack.Minigun2.M2RegFire'
+     AltFireSound=Sound'Botpack.Minigun2.M2AltFire'
      SelectSound=Sound'UnrealI.Minigun.MiniSelect'
-     Misc1Sound=Sound'Botpack.minigun2.M2WindDown'
+     Misc1Sound=Sound'Botpack.Minigun2.M2WindDown'
      DeathMessage="%k's %w turned %o into a leaky piece of meat."
      NameColor=(B=0)
      bDrawMuzzleFlash=True
@@ -582,7 +584,7 @@ defaultproperties
      BobDamping=0.975000
      PickupViewMesh=LodMesh'Botpack.MinigunPick'
      ThirdPersonMesh=LodMesh'Botpack.MiniHand'
-     StatusIcon=Texture'Botpack.Icons.UseMini'
+     StatusIcon=Texture'WFMedia.WeaponMachineGun'
      bMuzzleFlashParticles=True
      MuzzleFlashStyle=STY_Translucent
      MuzzleFlashMesh=LodMesh'Botpack.MuzzFlash3'
diff --git a/WFMedia/Classes/HUDTextures.uc b/WFMedia/Classes/HUDTextures.uc
index 9639de8..3ecefe4 100644
--- a/WFMedia/Classes/HUDTextures.uc
+++ b/WFMedia/Classes/HUDTextures.uc
@@ -6,6 +6,91 @@ class HUDTextures extends WFMediaInfo;
 // energy icon
 #exec TEXTURE IMPORT Name="EnergyHUDIcon" FILE=Textures\HUD\energy2hud.PCX MIPS=OFF
 
+// health icon
+#exec TEXTURE IMPORT Name="HealthIcon" FILE=Textures\HUD\health.pcx MIPS=OFF FLAGS=2
+// armour icon
+#exec TEXTURE IMPORT Name="ArmourIcon" FILE=Textures\HUD\armour.pcx MIPS=OFF FLAGS=2
+// resource icon
+#exec TEXTURE IMPORT Name="ResourceIcon" FILE=Textures\HUD\resource.pcx MIPS=OFF FLAGS=2
+
+// Connection lost icon
+#exec TEXTURE IMPORT Name="PLIcon" FILE=Textures\HUD\pl.pcx MIPS=OFF FLAGS=2
+
+
+// Hud backing
+
+#exec TEXTURE IMPORT Name="ModulatedPanelOne" FILE=Textures\HUD\panel1_modulated.pcx MIPS=OFF
+#exec TEXTURE IMPORT Name="NormalPanelOne" FILE=Textures\HUD\panel1_normal.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="ModulatedPanelTwo" FILE=Textures\HUD\panel2_modulated.pcx MIPS=OFF
+#exec TEXTURE IMPORT Name="NormalPanelTwo" FILE=Textures\HUD\panel2_normal.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="ModulatedPanelThree" FILE=Textures\HUD\panel3_modulated.pcx MIPS=OFF
+#exec TEXTURE IMPORT Name="NormalPanelThree" FILE=Textures\HUD\panel3_normal.pcx MIPS=OFF FLAGS=2
+
+// digits
+#exec TEXTURE IMPORT Name="DigitBlank" FILE=Textures\HUD\blank.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitZero"  FILE=Textures\HUD\zero.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitOne"   FILE=Textures\HUD\one.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitTwo"   FILE=Textures\HUD\two.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitThree" FILE=Textures\HUD\three.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitFour"  FILE=Textures\HUD\four.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitFive"  FILE=Textures\HUD\five.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitSix"   FILE=Textures\HUD\six.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitSeven" FILE=Textures\HUD\seven.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitEight" FILE=Textures\HUD\eight.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="DigitNine"  FILE=Textures\HUD\nine.pcx MIPS=OFF FLAGS=2
+
+// msg box
+
+#exec TEXTURE IMPORT Name="MsgBack" FILE=Textures\HUD\message_back.pcx MIPS=OFF
+#exec TEXTURE IMPORT Name="MsgBackEnd" FILE=Textures\HUD\message_back_end.pcx MIPS=OFF
+#exec TEXTURE IMPORT Name="MsgBall" FILE=Textures\HUD\message_ball.pcx MIPS=OFF FLAGS=2
+
+// weapon icons
+
+#exec TEXTURE IMPORT Name="WeaponImpactHammer" FILE=Textures\WeaponIcons\impacthammer.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponTranslocator" FILE=Textures\WeaponIcons\translocator.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponRocketLaucher" FILE=Textures\WeaponIcons\rocketlauncher.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponMiniFlak" FILE=Textures\WeaponIcons\miniflak.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponHyperblaster" FILE=Textures\WeaponIcons\hyperblaster.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponRailGun" FILE=Textures\WeaponIcons\railgun.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponPlasmaLaser" FILE=Textures\WeaponIcons\plasmalaser.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponSentryKiller" FILE=Textures\WeaponIcons\sentrykiller.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponTesla" FILE=Textures\WeaponIcons\teslacoil.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponRobotHand" FILE=Textures\WeaponIcons\robothand.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponGrenadeLauncher" FILE=Textures\WeaponIcons\grenadelauncher.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponPipeBombs" FILE=Textures\WeaponIcons\pipebombs.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponFlameThrower" FILE=Textures\WeaponIcons\flamethrower.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponNapalmRocketLauncher" FILE=Textures\WeaponIcons\napalmrocketlauncher.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponRDU" FILE=Textures\WeaponIcons\rdu.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponEnforcer" FILE=Textures\WeaponIcons\enforcer.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponSniperRifle" FILE=Textures\WeaponIcons\sniperrifle.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponMedKit" FILE=Textures\WeaponIcons\medkit.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponBioGun" FILE=Textures\WeaponIcons\biogun.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponMachineGun" FILE=Textures\WeaponIcons\machinegun.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponMegaChainCannon" FILE=Textures\WeaponIcons\megachaincannon.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="WeaponTazer" FILE=Textures\WeaponIcons\tazer.pcx MIPS=OFF FLAGS=2
+
+
+
+
+// grenade icons
+#exec TEXTURE IMPORT Name="GrenadeFrag" FILE=Textures\GrenadeIcons\frag.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="GrenadeTurret" FILE=Textures\GrenadeIcons\turret.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="GrenadeShock" FILE=Textures\GrenadeIcons\shock.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="GrenadeFlame" FILE=Textures\GrenadeIcons\flame.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="GrenadePlague" FILE=Textures\GrenadeIcons\plague.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="GrenadeConc" FILE=Textures\GrenadeIcons\concussion.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="GrenadeFlash" FILE=Textures\GrenadeIcons\flash.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="GrenadeEMP" FILE=Textures\GrenadeIcons\emp.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="GrenadeDecloaker" FILE=Textures\GrenadeIcons\decloaker.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="GrenadeFreeze" FILE=Textures\GrenadeIcons\freeze.pcx MIPS=OFF FLAGS=2
+
+// flag icons
+#exec TEXTURE IMPORT Name="FlagHome" FILE=Textures\HUD\flag_home.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="FlagDown" FILE=Textures\HUD\flag_down.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="FlagCapt" FILE=Textures\HUD\flag_capt.pcx MIPS=OFF FLAGS=2
+#exec TEXTURE IMPORT Name="FlagReturn" FILE=Textures\HUD\flag_return.pcx MIPS=OFF FLAGS=2
+
 defaultproperties
 {
 }
diff --git a/WFMedia/Classes/WFPLazerMedia.uc b/WFMedia/Classes/WFPLazerMedia.uc
index 2be925f..2c393a6 100644
--- a/WFMedia/Classes/WFPLazerMedia.uc
+++ b/WFMedia/Classes/WFPLazerMedia.uc
@@ -18,8 +18,6 @@ class WFPLazerMedia extends WFMediaInfo;
 #exec TEXTURE IMPORT NAME=JPLazer_01 FILE=Textures\Skins\PLazer_01.PCX GROUP=Skins FLAGS=2	//Material #26
 #exec TEXTURE IMPORT NAME=JPLazer_02 FILE=Textures\Skins\PLazer_02.PCX GROUP=Skins FLAGS=2	//Material #27
 #exec TEXTURE IMPORT NAME=JPLazer_03 FILE=Textures\Skins\PLazer_03.PCX GROUP=Skins FLAGS=2	//Material #28
-#exec TEXTURE IMPORT NAME=IconLazer FILE=TEXTURES\HUD\IconLazer.PCX GROUP="Icons" MIPS=OFF
-#exec TEXTURE IMPORT NAME=UseLazer FILE=TEXTURES\HUD\UseLazer.PCX GROUP="Icons" MIPS=OFF
 
 #exec MESHMAP SETTEXTURE MESHMAP=WFPlazer NUM=1 TEXTURE=JPLazer_01
 #exec MESHMAP SETTEXTURE MESHMAP=WFPlazer NUM=2 TEXTURE=JPLazer_02
diff --git a/WFSystem/Classes/WFS_PCSArmor.uc b/WFSystem/Classes/WFS_PCSArmor.uc
index 18a77e1..ac3ac4b 100644
--- a/WFSystem/Classes/WFS_PCSArmor.uc
+++ b/WFSystem/Classes/WFS_PCSArmor.uc
@@ -111,6 +111,12 @@ function int ArmorAbsorbDamage(int Damage, name DamageType, vector HitLocation)
 	return (Damage - ArmorDamage);
 }
 
+// negative values will reduce armor
+function AddArmor(int Amount)
+{
+	Charge = Clamp(Charge + Amount, 0, MaxCharge );
+}
+
 defaultproperties
 {
      bDisplayableInv=True
diff --git a/WFSystem/Classes/WFS_TestHWGuyInv.uc b/WFSystem/Classes/WFS_TestHWGuyInv.uc
index f88c4a0..2a1fe93 100644
--- a/WFSystem/Classes/WFS_TestHWGuyInv.uc
+++ b/WFSystem/Classes/WFS_TestHWGuyInv.uc
@@ -14,6 +14,6 @@ static function ModifyWeapon(weapon NewWeapon)
 
 defaultproperties
 {
-     Weapons(0)=Class'Botpack.minigun2'
+     Weapons(0)=Class'Botpack.Minigun2'
      Weapons(1)=Class'Botpack.UT_FlakCannon'
 }
